<script src="../libs/three/three.min.js"></script>
<script src="../libs/three/controls/TrackballControls.js"></script>
<script src="../libs/three/renderers/CSS3DRenderer.js"></script>
<script src="../libs/three/loaders/OBJLoader.js"></script>
<script src="../libs/three/loaders/ColladaLoader.js"></script>



<!-- ^
	TODO: Import dependencies via `import` and rollup/webpack instead.
	There are some issues with three.js though, because the extras, like controls, loaders
	are unfortunately not yet available as bundles without hacks.
-->


<link rel="import" href="annotation-box-3d.html">


<dom-module id="render-view">^

	<template>
		<style is="custom-style">


			:host {
				margin: 0;
				cursor: -webkit-grab;
				min-height: 100%;
				min-width: 100%;
			}

			:host.track {
				cursor: -webkit-grabbing;
			}

			:host:hover {}

			canvas {
				width: 100%;
				height: 100%;
			}

			:host.polygonCursor {
				cursor: crosshair;
			}
			:host.fingerCursor {
				cursor: pointer;
			}


		</style>


				<template is="dom-repeat" items="{{annotations}}" as="item">

					<annotation-box-3d class="annotationBox3D" id="annotationbox3d_[[item._id]]" active-profile="[[activeProfile]]" annotation="{{item}}" index="[[index]]" selected="[[_isSelected(selectedAnnotation._id, item._id)]]"  on-annotation-deleted-by-user="onAnnotationDeleted" on-tap="annotationBoxClicked" on-mouseover="annotationBoxMouseover"></annotation-box-3d>

				</template>




	</template>

	<script>
	'use strict' /*eslint global-strict:0*/

	var anime = require('animejs');

	// FIXME: shouldnt those global variables better reside inside the element
	// vis this.glRenderer = ...

	var glScene = new THREE.Scene();
	var cssScene = new THREE.Scene();
	var controls;
	var cssObject;
	var glRenderer;
	var cssRenderer;
	var render;
	var animate;

	function jsonEqual(a,b) {
    return JSON.stringify(a) === JSON.stringify(b);
	}

	Polymer({
		is: "render-view",

		properties: {
			fileRepresentation: Object,
			file: {
				type: Object,
				observer: '_fileChanged'
			},
			fileName: {
				type: String,
			},
			fileEnding: {
				type: String,
			},
			tool: {
				type: 'Object',
				observer: '_toolChanged'
			},
			activeProfile: {
				type: Object
			},
			annotations: {
				type: Array,
				observer: "_annotationsChanged"
			},
			labels: {
				type: Map
			},
			penState: {
				type: Object,
				observer: "penStateChanged"
			},
			physicalModelState: {
				type: Object,
				observer: "physicalModelStateChanged"
			},
			penStatus: {
				type: String
			},
			hoveredAnnotation: {
				type: Object,
				observer: "_hoveredAnnotationChanged"
			},
			selectedAnnotation: {
				type: Object,
				notify: true,
				observer: "_selectedAnnotationChanged"
			}
		},

		listeners: {
			'tap': 'tap',
			'up': 'toggleTrack',
			'down': 'toggleTrack',
			'track': 'track',
			'mousemove': 'mouseOrPenMoved'
		},
		_isSelected: function (selectedAnnotation, annotation) {
			return selectedAnnotation === annotation;
		},

		getStatusColor: function (status) {
			if(status === 'problem') {
				return 0xb82f2f;
			} else if (status === 'task') {
				return 0xdfd047;
			} else if (status === 'comment') {
				return 0x2f8bb7;
			}

		},


		ready: function() {
			// doesnt work with listeners on this very element
			// so create start event listener
			console.log('renderview ready');
			this.ready = true;
			this.rendering = false;
			document.addEventListener('keydown', this.keydown.bind(this));
		},

		startRendering: function() {
			if (this.rendering === false) {
				console.log('started rendering');
				this.rendering = true;
				animate();
			}
		},

		animate: function () {
			this.light.position.copy(this.camera.position).addScaledVector(this.camera.up, this.standardDistance);
			this.spotLight.position.copy(this.camera.position);
			requestAnimationFrame(this.animate.bind(this));
			controls.update();
		},

		render: function() {
			glRenderer.render(glScene, this.camera);
			cssRenderer.render(cssScene, this.camera);
		},

		resetGroups: function () {
			// Remove labels and annotations
			this.labels = new Map();
			this.spheres = [];
			this.annotation3DObjects = new Map();

			if(this.labelGroup && this.annotationGlGroups) {

				for( var i = this.labelGroup.children.length - 1; i >= 0; i--) {
					this.labelGroup.remove(this.labelGroup.children[i]);
					cssScene.remove(this.labelGroup.children[i]);
				}

				for( var i = this.annotationGlGroups.children.length - 1; i >= 0; i--) {
					this.annotationGlGroups.remove(this.annotationGlGroups.children[i]);
					glScene.remove(this.annotationGlGroups.children[i]);
				}
			}
		},




		createPen() {
			// Nesting: Offset -> Orientation -> Object

			// Add physical pen model
			this.penGroupGLOffset = new THREE.Group();
			this.penGroupGLOffset.rotateX(-0.5 * Math.PI);

			this.penGroupGLOrientation = new THREE.Group();
			this.penGroupGLOffset.add(this.penGroupGLOrientation);
			this.penGroupGL = new THREE.Object3D();
			this.penGroupGL.visible = false;
			this.penGroupGLOrientation.add(this.penGroupGL);

			glScene.add(this.penGroupGLOffset);

			let penGeometry = new THREE.BoxBufferGeometry(
				0.4 * this.standardDistance,
				0.1 * this.standardDistance,
				0.1 * this.standardDistance
			);
			let penMaterial = new THREE.MeshStandardMaterial({
				side: THREE.DoubleSide,
				color: 0x333333,
				roughness: 0.75,
				metalness: 0.2
			});

			this.physicalPenModel = new THREE.Mesh( penGeometry, penMaterial );
			this.physicalPenSpotLight = new THREE.SpotLight( 0xffeedd, 1, 3 * this.standardDistance, 0.20, 0.8, 1 );

			this.physicalPenModel.position.set(
				2.0 * this.standardDistance,
				// 0,
				0,
				0
			);
			const penAxisHelper = new THREE.AxisHelper(0.3 * this.standardDistance);
			penAxisHelper.position.copy(this.physicalPenModel.position);
			// this.penGroupGL.add(penAxisHelper);
			this.physicalPenSpotLight.position.copy(this.physicalPenModel.position);
			this.penGroupGL.add( this.physicalPenModel );
			this.penGroupGL.add( this.physicalPenSpotLight );

			let center = new THREE.Vector3(0, 0, 0);
			this.physicalPenSpotLight.worldToLocal(center);
			this.physicalPenSpotLight.lookAt(center);
		},

		penStateChanged: function () {
			if (this.penGroupGLOrientation) {
				this.penGroupGL.visible = true;
				const quaternion = this.penState.quat.clone();
				this.penGroupGLOrientation.setRotationFromQuaternion(quaternion);

				this.mouseOrPenMoved();
				requestAnimationFrame(() => this.render());
			}
		},

		physicalModelStateChanged: function () {

			if (this.mainGroupGL) {
				const quaternion = this.physicalModelState.quat.clone();
				this.mainGroupGL.setRotationFromQuaternion(quaternion);
				this.mainGroupCSS.setRotationFromQuaternion(quaternion);
			}

		},

		attached: function() {
			this.modus = {modelGrabbing: false, hiddenLabels: true};

			let width = this.parentNode.getBoundingClientRect().width;
			let height = this.parentNode.getBoundingClientRect().height;
			this.standardDistance = 500;
			this.camera = new THREE.PerspectiveCamera(50, width / height, this.standardDistance / 100, this.standardDistance * 100);
			this.camera.position.set(
				2 * this.standardDistance,
				2 * this.standardDistance,
				2 * this.standardDistance
			);

			glRenderer = new THREE.WebGLRenderer({
				antialias: true,
				alpha: true
			});
			glRenderer.setClearColor(0x00ff00, 0.0);
			glRenderer.setSize(width, height);
			// QUESTION: when to do the following?
			//glRenderer.setPixelRatio(window.devicePixelRatio);
			glRenderer.shadowMapEnabled = true;

			// cssRenderer is used for font rendering
			cssRenderer = new THREE.CSS3DRenderer();
			cssRenderer.setSize(width, height);

			// let both renderers/canvases overlap
			glRenderer.domElement.style.position = 'absolute';
			glRenderer.domElement.style.top = 0;
			cssRenderer.domElement.style.position = 'absolute';
			cssRenderer.domElement.style.top = 0;


			this.meshMaterial = new THREE.MeshStandardMaterial({
				side: THREE.DoubleSide,
				color: 0x787878,
				roughness: 0.2,
				metalness: 0.8,
				transparent: true,
				opacity: 0.75
			})

			this.atmosphericLight = new THREE.DirectionalLight(0x556677, 0.6);
			this.atmosphericLight.position.set(20 * this.standardDistance, 20 * this.standardDistance, -2.5 * this.standardDistance);

			this.atmosphericLight2 = new THREE.DirectionalLight(0x1166bb, 0.8);
			this.atmosphericLight2.position.set(-20 * this.standardDistance, 20 * this.standardDistance, 2.5 * this.standardDistance);

			this.atmosphericLight3 = new THREE.DirectionalLight(0xff6600, 0.8);
			this.atmosphericLight3.position.set(-20 * this.standardDistance, 20 * this.standardDistance, 2.5 * this.standardDistance);
			//
			this.atmosphericLight4 = new THREE.DirectionalLight(0xff6600, 0.5);
			this.atmosphericLight4.position.set(0, -20 * this.standardDistance, 0);

			this.light = new THREE.PointLight( 0xccddff, 1, 1.0 );
			this.spotLight = new THREE.SpotLight( 0xffddbb, 1, 0, 0.25, 1, 1.0 );

			// glScene.add(this.atmosphericLight);
			glScene.add(this.atmosphericLight2);
			glScene.add(this.atmosphericLight3);
			// glScene.add(this.atmosphericLight4);
			glScene.add(this.light);
			glScene.add(this.spotLight);

			this.floorMaterial = new THREE.MeshStandardMaterial({
				color: 0xb9b9b9,

				transparent: true,
				opacity: 0.05,
				side: THREE.DoubleSide
			});
			this.floor = new THREE.Mesh(new THREE.PlaneBufferGeometry(this.standardDistance * 4, this.standardDistance * 4, 2, 2), this.floorMaterial);
			glScene.add(this.floor);
			// console.log(this.floor.up);
			this.floor.rotateX(-0.5 * Math.PI);
			// console.log(this.floor.up);
			// setInterval(() => {
			// 	this.floor.rotateX(Math.random() * Math.PI);
			// 	this.floor.rotateX(Math.random() * Math.PI);
			// 	this.floor.rotateX(Math.random() * Math.PI);
			// 	console.log('localup:', JSON.stringify(this.floor.up));
			// 	let up2 = this.floor.up.clone();
			// 	this.floor.localToWorld(up2);
			// 	console.log('worldup:', JSON.stringify(up2));
			// 	this.render();
			// }, 100);
			// // console.log(this.floor.rotation.z);

			glRenderer.domElement.id = 'glRenderer';
			cssRenderer.domElement.id = 'cssRenderer';
			Polymer.dom(this.root).appendChild(glRenderer.domElement);
			Polymer.dom(this.root).appendChild(cssRenderer.domElement);

			if (this.labelGroup === undefined)
				this.labelGroup = new THREE.Object3D();
			if (this.annotationGlGroups === undefined)
				this.annotationGlGroups = new THREE.Object3D();

			this.createPen();

			//cssScene.add(this.labelGroup);
			//glScene.add(this.annotationGlGroups);
			this.resetGroups();

			// setup 3d-controls (rotating the camera with cursor)
			controls = new THREE.TrackballControls(this.camera, this);
			controls.rotateSpeed = 1.0;
			controls.zoomSpeed = 1.2;
			controls.panSpeed = 0.8;
			controls.noZoom = false;
			controls.noPan = false;
			controls.staticMoving = true;
			controls.dynamicDampingFactor = 0.3;
			controls.keys = [65, 83, 68];

			// add cursor pointer to 3D scene
			this.sphereGeometry = new THREE.SphereGeometry( this.standardDistance / 60, 10, 10 );
			this.sphereMaterial = new THREE.MeshToonMaterial( {color: 0x122122, shininess: 0.5, diffuse: 0.5, reflectivity: 0  } );
			this.pointerSphere = new THREE.Mesh( this.sphereGeometry, this.sphereMaterial );
			glScene.add(this.pointerSphere);

			var axisHelper = new THREE.AxisHelper( this.standardDistance );
			// glScene.add( axisHelper );

			// create Raycaster used for polygon editing tool
			this.raycaster = new THREE.Raycaster()

			controls.addEventListener('change', this.render.bind(this))
			controls.addEventListener('change', this.updateAllAnnotationVisibility.bind(this))
			controls.handleResize()

			// init annotations to empty array
			this.annotations = [];
			this.annotation3DObjects = new Map();
			this.hoveredAnnotation = null;

			this.annotationMoveTimeout = undefined;

			this.resize();
			this.fire('initialized')
		},

		getPenPosition() {
			return this.penGroupGLOffset;
		},

		resize: function(event) {
			let width = this.parentNode.getBoundingClientRect().width;
			let height = this.parentNode.getBoundingClientRect().height;
			glRenderer.setSize(width, height);
			cssRenderer.setSize(width, height);
			this.camera.aspect = width / height;
			this.camera.updateProjectionMatrix();
			controls.handleResize();
			this.render();
		},

		_fileChanged: function () {
			console.log('fileChanged')
			console.log(this.file)

			this.resetGroups();
			this.annotations = [];

			// load the file and use it for display
			var loader;
			console.log('FILE ENDING:', this.fileEnding);
			if(this.fileEnding === 'obj') {
				loader = new THREE.OBJLoader();
			} else if (this.fileEnding === 'dae') {
				loader = new THREE.ColladaLoader();
			} else {
				console.error('Cannot load file with filending', this.fileEnding, '. This should have been catched at file upload.');
			}

			var filepath = URL.createObjectURL(this.file)
			loader.load(filepath,
				model  => {
					console.log(model);
					let meshFromFile = new THREE.Object3D();
					if(this.fileEnding === 'obj') {
						meshFromFile = model;
					} else if (this.fileEnding === 'dae') {

						for (let geometry of Object.values(model.dae.geometries)	) {
							console.log(geometry.mesh.geometry3js);
							meshFromFile.add(new THREE.Mesh(geometry.mesh.geometry3js, this.meshMaterial));
						}

					}

					// const meshFromFile = new THREE.Mesh(geometry, this.meshMaterial);
					this.boundingBox = new THREE.Box3().setFromObject(meshFromFile);
					this.maxLength = Math.max(this.boundingBox.max.x, this.boundingBox.max.y, this.boundingBox.max.z);
					// TODO: Save scale factor in DB.
					meshFromFile.scale.set(this.standardDistance/this.maxLength, this.standardDistance/this.maxLength, this.standardDistance/this.maxLength);
					var height = this.boundingBox.size().y;
					var pos = glScene.position;


					// swap existing mesh with new mesh
					if (this.fileRepresentation !== undefined)
						this.mainGroupGL.remove(this.fileRepresentation);

					this.fileRepresentation = meshFromFile;


					this.mainGroupCSS = new THREE.Object3D();
					this.mainGroupGL = new THREE.Object3D();
					this.mainGroupGLOffset = new THREE.Group();
					this.mainGroupCSSOffset = new THREE.Group();

					this.mainGroupGLOffset.rotateX(-0.5 * Math.PI);
					this.mainGroupCSSOffset.rotateX(-0.5 * Math.PI);

					glScene.add(this.mainGroupGLOffset);
					glScene.add(this.mainGroupCSSOffset);

					this.mainGroupCSSOffset.add(this.mainGroupCSS);
					this.mainGroupGLOffset.add(this.mainGroupGL);

					// create group for text annotations in 3D
					if (this.labelGroup === undefined)
						this.labelGroup = new THREE.Object3D();
					if (this.annotationGlGroups === undefined)
						this.annotationGlGroups = new THREE.Object3D();

					let mainGroupAxisHelper = new THREE.AxisHelper( this.standardDistance );
					// this.mainGroupGL.add(mainGroupAxisHelper)
					this.mainGroupCSS.add(this.labelGroup);
					this.mainGroupGL.add(this.annotationGlGroups);
					this.mainGroupGL.add(this.fileRepresentation);
					glScene.add(this.penGroupGLOffset);
					cssScene.add(this.mainGroupCSSOffset);


					this.render();
					this.animate();
				}
			);
		},

		_annotationsChanged: function(newAnnotations, oldAnnotations) {

			// debug output of annotations
			// first remove all previous annotations
			//
			// !!!IMPORTANT Performance FIXME!!!: only update modified ones, instead of removing and completely re-creating
			//
			//



			// Following part has to be async because the annotation-box-3d's may not ready yet in this tick.
			// Polymer.dom.flush();
			this.async(function() {

				this.resetGroups();
				for (let annotation of this.annotations) {
					this.addAnnotationObject(annotation);
				}


				this.render();
			});

		},


		removeAnnotationObjects: function (annotations) {
			for (let annotation of annotations) {
				let glGroup = this.annotation3DObjects.get(annotation._id).glGroup;
				this.annotationGlGroups.remove(glGroup);

				console.log('also remove the labels please!');
				let label = this.labels.get(annotation._id);
				console.log(label);
				this.labelGroup.remove(label);
				cssScene.remove(label);

				glScene.remove(glGroup);
			}
		},

		changeAnnotationObjects: function (annotations) {
			for (let annotation of annotations) {
				let glGroup = this.annotation3DObjects.get(annotation._id).glGroup;
				this.annotationGlGroups.remove(glGroup);

				console.log('also remove the labels please!');
				let label = this.labels.get(annotation._id);
				console.log(label);
				this.labelGroup.remove(label);
				cssScene.remove(label);

				glScene.remove(glGroup);
			}
		},

		addAnnotationObject: function (annotation) {
			let annotation3DObject = {};
			let annotationGlGroup = new THREE.Object3D();
			annotationGlGroup.userData = {_id: annotation._id};
			let multFactor = 2.0;

			let label = this.createLabel(annotation, multFactor);

			this.labels.set(annotation._id, label);
			this.labelGroup.add(label);
			annotation3DObject.label = label;

			// TODO: add arrow, label to a group/structure to be selectable
			let arrow = this.createArrow(annotation.worldPosition, label.position, annotation.status);
			annotationGlGroup.add(arrow);
			annotation3DObject.arrow = arrow;

			let sphere = new THREE.Mesh(
				this.sphereGeometry,
				this.sphereMaterial.clone()
			);
			sphere.scale.set(2.0, 2.0, 2.0);

			sphere.material.color.setHex(this.getStatusColor(annotation.status));
			console.log(annotation);
			sphere.position.copy(annotation.worldPosition);
			annotationGlGroup.add(sphere);
			annotation3DObject.sphere = sphere;
			this.spheres.push(sphere);




			// if annotation has polygon info, create it and add it to the scene
			if (annotation.polygon !== undefined) {
				let polygon = this.createPolygon(annotation.polygon, annotation.creatorProfile.color);
				annotationGlGroup.add(polygon)
				annotation3DObject.polygon = polygon
			}
			this.annotationGlGroups.add(annotationGlGroup);
			annotation3DObject.glGroup = annotationGlGroup;
			this.annotation3DObjects.set(annotation._id, annotation3DObject);
			return annotation3DObject;
		},
		_hoveredAnnotationChanged: function () {

		},

		updateAllAnnotationVisibility: function () {
			// TODO: there is a PR on threejs for raycasting in css renderer, use it once ready
			// triggered on controls update
			let raycaster = new THREE.Raycaster();
			if(this.modus.hiddenLabels) {
				// Hide all Annotations (except red pinpoint) by default
				// and conditionally unhide the hovered annotation
				// This is not super efficient (toggling all every time) but should suffice in this case
				// console.log(this.annotation3DObjects.values());
				for (let {label, arrow} of this.annotation3DObjects.values()) {
					label.element.style.display = 'none';
					label.element.style.opacity = 0.0;
					arrow.visible = false;
				}

				let visibleAnnotations = [];
				if(this.hoveredAnnotation) visibleAnnotations.push(this.hoveredAnnotation);
				if(this.selectedAnnotation) {
					visibleAnnotations.push(this.selectedAnnotation);
					if(this.selectedAnnotation.referingTo) {
						for (let _id of this.selectedAnnotation.referingTo) {
							visibleAnnotations.push({_id});
						}
					}



				}
				// visibleAnnotations = visibleAnnotations.concat(this.annotations.filter(annotation => annotation.hidden));



				for (let annotation of visibleAnnotations) {
					if(!annotation) continue;
					let {label, arrow} = this.annotation3DObjects.get(annotation._id);
					arrow.visible = true;
					label.element.style.display = 'block';
					label.element.style.opacity = 0.9;
				}

			}


			// if (this.labelGroup.children === undefined) return

			// for(let label of this.labelGroup.children) {
			// 	let normalizedDirection = (label.position.clone().sub(this.camera.position)).normalize()
			// 	raycaster.set(this.camera.position.clone(), normalizedDirection)
			// 	raycaster.far = this.camera.position.distanceTo(label.position)
			// 	let intersections = raycaster.intersectObject(this.fileRepresentation, true)
			// 	if (intersections.length !== 0) {
			// 		label.element.style.opacity = 0.0
			// 	} else {
			// 		label.element.style.opacity = 0.9;
			// 	}
			// }

			this.render()

		},

		toggleTrack: function(e) {
			this.modus.modelGrabbing = !this.modus.modelGrabbing;
			this.movingAnnotation = undefined;
			Polymer.dom(this).classList.toggle('track');
		},

		updateMouse: function (mouseEvent) {
			let canvas = this.$$('canvas');
			this.mouse = new THREE.Vector2(
				(mouseEvent.layerX / canvas.width) * 2/*window.devicePixelRatio*/ - 1,
				-((mouseEvent.layerY / canvas.height) * 2/*window.devicePixelRatio*/ - 1)
			);
		},

		mouseOrPenMoved(event) {
			this.previousCameraPosition = controls.object.position.clone();
			this.previousCameraRotation = controls.object.rotation.clone();


			// To determine whether the pen is active we got an event
			// this is a HACK; should be made more intuitive.
			this.penActive = event === undefined;
			if (!this.penActive) {
				this.updateMouse(event);
			}


			Polymer.dom(this).classList.remove('polygonCursor');
			Polymer.dom(this).classList.remove('fingerCursor');

			let sphereIntersection;

			if(true /* testing: always true*/ || this.modus.hiddenLabels || this.tool === 'move') {
				// console.log(this.mouse, this.camera);
				sphereIntersection = this.getSphereIntersection();
				this.hoveredAnnotation = undefined;
				if(sphereIntersection !== undefined) {
					let _id = sphereIntersection.object.parent.userData._id;
					// Get new hoveredAnnotation and make it visible
					this.hoveredAnnotation = this.annotations.find(el => el._id === _id);
					// console.log(sphereIntersections[0].object.parent);
					Polymer.dom(this).classList.add('fingerCursor');
				}

			}



			let objectIntersections = [];

			if (this.fileRepresentation) {
				// console.log('tool',this.tool);
				if (!this.penActive && (this.tool === 'polygon' || this.tool === 'point' || this.tool === 'move')) {
					this.raycaster.setFromCamera(this.mouse, this.camera);
				} else if(this.penActive) {
					// console.log('use pen position for raycaster');
					const origin = this.physicalPenModel.getWorldPosition();
					const normalizedDirection = origin.clone().negate().normalize();
					this.raycaster.set(origin, normalizedDirection);
				}

				if(this.penActive || this.tool !== 'rotate') {
					objectIntersections = this.getObjectIntersections();
				}
			}


			let originalIntersection;
			if (objectIntersections !== undefined) {
				originalIntersection = objectIntersections[0];
			}

			if (originalIntersection !== undefined || sphereIntersection !== undefined) {

				if (this.modus.modelGrabbing && this.tool !== 'rotate') {
					if(this.hoveredAnnotation && this.tool === 'move') {
						Polymer.dom(this).classList.add('fingerCursor');
					} else {
						Polymer.dom(this).classList.add('polygonCursor');
					}

				}
				this.spotLight.target = this.pointerSphere;
				if(originalIntersection !== undefined) {
					let objectIntersections = this.getObjectIntersections();

					// The pointerSphere is in global space and
					// requires the original intersection position
					this.pointerSphere.position.copy(originalIntersection);
				}
				this.render();

			} else {

			}

			// FIXME: update only on actual change
			this.updateAllAnnotationVisibility();

		},

		keydown: function (e) {
			if (e.defaultPrevented) {
				return; // Should do nothing if the key event was already consumed.
			}

			switch (e.which) {
				case 13: /*Enter*/
					if (this.tool === 'polygon' && this.verticesPolygonTool.length !== 0){
						event.preventDefault();
						// TODO: finish shape and create annotation
						this.fire('create-annotation', {
							description: '',
							polygon: this.verticesPolygonTool,
							position: this.verticesPolygonTool[0],
							worldCameraPosition: worldCameraPosition,
							localCameraPosition: localCameraPosition,
							// cameraRotation: camera.rotation,
							cameraUp: this.camera.up
						});
						if (this.previewAnnotation !== undefined) {
							this.mainGroupGL.remove(this.previewAnnotation.arrow);
							this.mainGroupGL.remove(this.previewAnnotation.polygon);
							this.mainGroupCSS.remove(this.previewAnnotation.label);
							this.previewAnnotation = undefined;
						}
						glScene.remove(this.previewPolygon);
						this.previewPolygon = undefined;
						this.verticesPolygonTool = [];
						console.log('added polygon annotation');
					}
					break;
					case 27 /* Escape */:
						console.log(this.previewAnnotation);
						if (this.previewPolygon !== undefined){
							glScene.remove(this.previewPolygon);
							this.previewPolygon = undefined;
						}

						if(this.previewAnnotation !== undefined) {
							// Remove preview annotation
							this.annotationGlGroups.remove(this.previewAnnotation.glGroup);
							this.labelGroup.remove(this.previewAnnotation.label);
							this.previewAnnotation = undefined;
						}

						this.verticesPolygonTool = [];
						requestAnimationFrame(this.render.bind(this));
					break;
				default:

					break;
			}
		},

		track: function (e) {
			controls.enabled = true;
			e.stopPropagation();
			if(this.tool === 'move') {



				// the user wants to move the hovered annotation
				// therefore remember a reference to this annotation
				// in case we loose hovering when user moves cursor too fast
				if(this.hoveredAnnotation && this.movingAnnotation === undefined) {

					this.movingAnnotation = this.hoveredAnnotation;

				} else if(this.movingAnnotation) {

					controls.enabled = false;

					let objectIntersections = this.getObjectIntersections();
					if (objectIntersections !== undefined) {
						var [originalIntersection, localPosition, worldPosition] = objectIntersections;
					}


					let id = this.movingAnnotation._id;
					clearTimeout(this.annotationMoveTimeout);
					this.annotationMoveTimeout = setTimeout(() => {
						this.fire('edit-annotation',
							{annotation: {_id: id, worldPosition, localPosition}, elem: this}
						);
						this.movingAnnotation = undefined;
					}, 1000);


					let targetAnnotation = this.annotations.filter(({_id}) => _id === id)[0];
					targetAnnotation.worldPosition = worldPosition;
					this.removeAnnotationObjects([targetAnnotation]);
					this.addAnnotationObject(targetAnnotation);


				}
			}
		},
		getSphereIntersection: function () {
			this.raycaster.setFromCamera(this.mouse, this.camera);

			let intersections = this.raycaster.intersectObjects(this.spheres, false);
			if(intersections.length > 0) {
				return intersections[0];
			}
		},

		getObjectIntersections: function () {

			if (!this.penActive && (this.tool === 'polygon' || this.tool === 'point' || this.tool === 'move')) {
				this.raycaster.setFromCamera(this.mouse, this.camera);
			} else if(this.penActive) {
				// console.log('use pen position for raycaster');
				const origin = this.physicalPenModel.getWorldPosition();
				const normalizedDirection = origin.clone().negate().normalize();
				this.raycaster.set(origin, normalizedDirection);
			}

			this.fileRepresentation.updateMatrixWorld();

			// Calculate objects intersecting the picking ray
			const intersections = this.raycaster.intersectObject(this.fileRepresentation, true);

			// only use the first/frontmost intersection  -> [0]
			const intersection = ( intersections.length ) > 0 ? intersections[ 0 ] : undefined;

			// Transform intersection point from world coordinates
			// to the local coordinate space of the mainGroupGL/mainGroupCSS (both equival. matrix)
			let localIntersectionPoint;
			let worldIntersectionPoint;
			let localCameraPosition;
			let worldCameraPosition;

			if(intersection) {
				this.selectedAnnotation = undefined;
				worldIntersectionPoint = intersection.point.clone();
				localIntersectionPoint = intersection.point.clone();
				localCameraPosition = controls.object.position.clone();
				worldCameraPosition = localCameraPosition.clone();

				this.fileRepresentation.worldToLocal(localIntersectionPoint);
				this.mainGroupGL.worldToLocal(worldIntersectionPoint);
				this.fileRepresentation.worldToLocal(localCameraPosition);

				// console.log('\n\noriginal Intersection:', JSON.stringify(intersection.point));
				// console.log('\nworld intersection (worldToMainGroup)', JSON.stringify(worldIntersectionPoint));
				// console.log('\nlocal intersection (worldToFileRep)', JSON.stringify(localIntersectionPoint));

				return [intersection.point.clone(), localIntersectionPoint, worldIntersectionPoint, localCameraPosition, worldCameraPosition];
			}

		},

		tap: function(e) {
			console.log('tap in render view');
			if (jsonEqual(this.previousCameraPosition, this.camera.position) === false || jsonEqual(this.previousCameraRotation, this.camera.rotation) == false) {
				console.log('moved! return!');
			}

			// Update values for this.mouse form event object so raycaster works
			this.updateMouse(e.detail.sourceEvent);

			// First check on annotation sphere intersection
			// If we clicked one, toggle selection of it.
			let sphereIntersection = this.getSphereIntersection();
			if(sphereIntersection !== undefined) {
				let _id = sphereIntersection.object.parent.userData._id;
				let annotation = this.annotations.find(el => el._id === _id);

				if(this.selectedAnnotation && this.selectedAnnotation._id === annotation._id) {
					// uncomment to make it possible to deselect annotation by clicking again on it
					//this.selectedAnnotation = undefined;
				} else {
					this.selectedAnnotation = annotation;
				}
				// annotation.hidden = !annotation.hidden;

				// if clicked on annotation, do not try to create annoation
				// and return immediately.
				return
			}

			let objectIntersections = this.getObjectIntersections();
			if (objectIntersections !== undefined) {
				var [originalIntersection,
						localIntersectionPoint,
						worldIntersectionPoint,
						localCameraPosition,
						worldCameraPosition] = objectIntersections;
			}

			switch (this.tool) {

				case 'point':
						console.log('CREATE NEW ANNOTATION AT COORDINATES:', localIntersectionPoint.clone());
						event.preventDefault();
						// TODO: finish shape and create annotation
						this.fire('create-annotation', {
							description: '',
							polygon: [worldIntersectionPoint.clone()],
							localPosition: localIntersectionPoint,
							worldPosition: worldIntersectionPoint,
							worldCameraPosition: worldCameraPosition,
							localCameraPosition: localCameraPosition,
							// cameraRotation: camera.rotation,
							cameraUp: controls.object.up
						});
						if (this.previewAnnotation !== undefined) {
							this.mainGroupGL.remove(this.previewAnnotation.arrow);
							this.mainGroupGL.remove(this.previewAnnotation.polygon);
							this.mainGroupCSS.remove(this.previewAnnotation.label);
							this.previewAnnotation = undefined;
						}
						glScene.remove(this.previewPolygon);
						this.previewPolygon = undefined;
						this.verticesPolygonTool = [];
						console.log('added polygon annotation');

					break;
				case 'move':

				break;
				case 'polygon':
					console.warn('FIX POLYGON POSITIONS BY APPLYING SAME TRANSFORMATIONS AS POINT; LATER ALSO SAVE LOCALPOSITION BY WORLDTOLOCAL FROM FILEREP');
					this.verticesPolygonTool.push(localIntersectionPoint.clone());

					// create new preview polygon/shape when enough points are available
					if (this.verticesPolygonTool.length >= 3) {
							glScene.remove(this.previewPolygon);
							this.previewPolygon = this.createPolygon(this.verticesPolygonTool, 0x00ff00);
							glScene.add(this.previewPolygon);
					}

					// And show a temporary preview annotation if first tap.
					if (this.previewAnnotation === undefined) {
						this.previewAnnotation = this.addAnnotationObject({
							_id: 'previewAnnotation',
							status: 'comment',
							description: "Press Enter to edit/create. Esc to cancel.",
							localPosition: localIntersectionPoint.clone(),
							worldPosition: worldIntersectionPoint.clone(),
							localCameraPosition: localCameraPosition,
							worldCameraPosition: worldCameraPosition,
							cameraUp: this.camera.up
						});
					}

					this.render();
				break;

				case 'setCamera':
					console.log('SET CAMERA');
					console.log(this.camera.quaternion, this.camera.position, this.camera.up);
					this.resetCamera = this.camera.clone();

				break;

				case 'resetCamera':
					console.log(this.camera.quaternion, this.camera.position, this.camera.up);

					this.camera.quaternion.copy(this.resetCamera.quaternion);
					this.camera.position.copy(this.resetCamera.position);
					this.camera.up.copy(this.resetCamera.up);

				break;

				case 'bottom':
					// HACK: for testing
					//
					let normals = this.fileRepresentation.geometry.getAttribute('normal').array;
					let faces = this.fileRepresentation.geometry.getAttribute('normal').array;
					console.log(this.fileRepresentation.geometry);
					let localIntersection = new THREE.Object3D();

					localIntersection.position.copy(intersection.point);
					this.mainGroupGL.add(localIntersection);

					let bottomNormal = new THREE.Vector3(
						normals[(intersection.faceIndex*3)],
						normals[(intersection.faceIndex*3) + 1],
						normals[(intersection.faceIndex*3) + 2]
					);

					// console.log(this.fileRepresentation.geometry.getAttribute('faces'));
					let face = new THREE.Face3(
						faces[(intersection.faceIndex*3)],
						faces[(intersection.faceIndex*3) + 1],
						faces[(intersection.faceIndex*3) + 2]
					);


					this.mainGroupGL.quaternion.setFromUnitVectors(bottomNormal, new THREE.Vector3(0, -1, 0));
					this.mainGroupGL.updateMatrixWorld();
					this.mainGroupGL.updateMatrix();
					localIntersection.updateMatrix();
					localIntersection.updateMatrixWorld();

					// TODO: Rotation works. Position has yet to be done correctly!

					// console.log(localIntersection.getWorldPosition(), localIntersection.position);
					// let dist = localIntersection.position.distanceTo(this.floor.position);
					// if(localIntersection.position.y > 0) {
					// 	console.log('tiefer bringen');
					// 	this.mainGroupGL.position.y -= dist;
					// } else {
					// 	console.log('h√∂her bringen');
					// 	this.mainGroupGL.position.y += dist;
					// }

					this.render();





					// this.mainGroupGL.position.sub(norm);

				break;
				default:
			}
		},

		createPolygon: function (vertices, color) {
			// IDEA: move to helper object?
			let polygon = new THREE.Geometry();
			polygon.vertices = vertices;

			// calculate faces of preview polygon
			for (var i = 1; i < polygon.vertices.length - 1; i++) {
				polygon.faces.push( new THREE.Face3( 0, i, i+1 ) )
			}
			return new THREE.Mesh(
				polygon,
				new THREE.MeshBasicMaterial( {
					color: color,
					side: THREE.DoubleSide
				} )
			);
		},

		createLabel: function (annotation, multFactor) {
			// let div = document.createElement('annotation-box-3d');
			// let div = document.createElement('div');
			// let textElement = document.createElement('span');

			// div.annotation = annotation;
			Polymer.dom.flush();
			let div = this.$$(`#annotationbox3d_${CSS.escape(annotation._id)}`);


			// TODO: disable any raycaster stuff etc. when interacting with label

			// div.addEventListener('mouseover', () => {
			// 	this.fire('label-over', annotation._id);
			// });
			// div.addEventListener('mouseout', () => {
			// 	this.fire('label-out', annotation._id);
			// });

			let label = new THREE.CSS3DSprite(div);
			label.userData.div = div;

			if (annotation.worldCameraPosition !== undefined) {
				// Convert x,y,z object into Vector3 object.
				let camPos = new THREE.Vector3(annotation.worldCameraPosition.x, annotation.worldCameraPosition.y, annotation.worldCameraPosition.z);
				if(camPos && this.mainGroupGL) {
					let labelPos = this.mainGroupGL.worldToLocal(camPos);
					label.position.copy(labelPos).multiplyScalar(0.6);

				}
			} else {
				label.position.set(annotation.worldPosition.x, annotation.worldPosition.y, annotation.worldPosition.z);
				label.position.multiplyScalar(multFactor);
			}
			return label;
		},

		createArrow: function (point, labelpos, status) {

			console.log(status);
			console.log(this.getStatusColor(status));

			var material = new THREE.LineBasicMaterial({
				linewidth: 15,
				color: this.getStatusColor(status)
			})

			var geometry = new THREE.Geometry()
			geometry.vertices.push(
				point,
				labelpos
			);

			return new THREE.Line( geometry, material );
		},

		_toolChanged: function(e) {
			// this is render-view's event listener on the toolBox
			// when a different tool is selected, this function is triggered
			console.log('tool changed.');
			//do some cleanup/inits
			glScene.remove(this.previewPolygon);
			this.previewPolygon = undefined;
			this.verticesPolygonTool = [];

			switch (this.tool) {
				case 'rotate': this.modus.modelGrabbing = true;
					break;
				default:
					break;
			}
		},

		_selectedAnnotationChanged: function (newSelected, oldSelected) {
			console.log('SELECTED ANNOTATION CHANGED IN RENDER VIEW');
			if (this.selectedAnnotation) {
				console.log('SELECTED ANNOTATION');
				console.log(this.selectedAnnotation);
				// The resetFrom function was added by me (modified .reset()) to allow
				// reset from a saved position (eg. stored in the DB)
				let selectedAnnotation = this.selectedAnnotation;
				if(selectedAnnotation.worldCameraPosition !== undefined){
					console.log(this.penStatus);

					if(this.penStatus === 'connected') {
						controls.resetFrom(selectedAnnotation.worldCameraPosition, selectedAnnotation.up);
					} else {
						console.log(this.camera);
						let animObj = {
							x: this.camera.position.x,
							y: this.camera.position.y,
							z: this.camera.position.z,
							x_up: this.camera.up.x,
							y_up: this.camera.up.y,
							z_up: this.camera.up.z
						};



						anime({
							targets: animObj,
							x: selectedAnnotation.worldCameraPosition.x,
							y: selectedAnnotation.worldCameraPosition.y,
							z: selectedAnnotation.worldCameraPosition.z,
							up: selectedAnnotation.cameraUp,
							round: 1,
							easing: 'easeInQuart',
							update: function() {
								let pos = new THREE.Vector3(animObj.x, animObj.y, animObj.z);
								let up = new THREE.Vector3(animObj.x_up, animObj.y_up, animObj.z_up);
								controls.resetFrom(pos, up);
							}
						});
					}

				}
			}

		},

		annotationBoxClicked: function (evt) {
			console.log('fire');
			this.fire('annotation-box-clicked', evt);
		}
	})
	</script>

</dom-module>
