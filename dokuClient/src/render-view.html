<script src="../libs/three/three.min.js"></script>
<script src="../libs/three/controls/TrackballControls.js"></script>
<script src="../libs/three/renderers/CSS3DRenderer.js"></script>
<script src="../libs/three/loaders/STLLoader.js"></script>
<link rel="import" href="annotation-box-3d.html">

<dom-module id="render-view">

	<template>
		<style is="custom-style">


			:host {
				margin: 0;
				cursor: -webkit-grab;
				min-height: 100%;
				min-width: 100%;
			}

			:host.track {
				cursor: -webkit-grabbing;
			}

			:host:hover {}

			canvas {
				width: 100%;
				height: 100%;
			}

			:host.polygonCursor {
				cursor: crosshair;
			}
			:host.fingerCursor {
				cursor: pointer;
			}
		</style>


				<template is="dom-repeat" items="{{annotations}}" as="item">

					<annotation-box-3d class="annotationBox3D" id="annotationbox3d_[[item._id]]" annotation="{{item}}" index="[[index]]" on-edit-annotation="onAnnotationBoxEdit" on-annotation-deleted-by-user="onAnnotationDeleted" on-tap="annotationBoxClicked" on-mouseover="annotationBoxMouseover"></annotation-box-3d>

				</template>




	</template>

	<script>
	'use strict' /*eslint global-strict:0*/

	// FIXME: shouldnt those global variables better reside inside the element
	// vis this.glRenderer = ...

	var glScene = new THREE.Scene();
	var cssScene = new THREE.Scene();
	var controls;
	var cssObject;
	var glRenderer;
	var cssRenderer;
	var render;
	var animate;

	function jsonEqual(a,b) {
    return JSON.stringify(a) === JSON.stringify(b);
	}

	Polymer({
		is: "render-view",

		properties: {
			fileRepresentation: Object,
			file: {
				type: Object,
				observer: '_fileChanged'
			},
			tool: {
				type: 'Object',
				observer: '_toolChanged'
			},
			annotations: {
				type: Array,
				observer: "_annotationsChanged"
			},
			labels: {
				type: Map
			},
			penState: {
				type: Object,
				observer: "penStateChanged"
			},
			physicalModelState: {
				type: Object,
				observer: "physicalModelStateChanged"
			},
			hoveredAnnotation: {
				type: Object,
				observer: "_hoveredAnnotationChanged"
			},
			selectedAnnotation: {
				type: Object,
				observer: "_selectedAnnotationChanged"
			}
		},

		listeners: {
			'tap': 'tap',
			'up': 'toggleTrack',
			'down': 'toggleTrack',
			'track': 'track',
			'mousemove': 'mouseOrPenMoved'
		},

		ready: function() {
			// doesnt work with listeners on this very element
			// so create start event listener
			console.log('renderview ready');
			this.ready = true;
			this.rendering = false;
			document.addEventListener('keydown', this.keydown.bind(this));
		},

		startRendering: function() {
			if (this.rendering === false) {
				console.log('started rendering');
				this.rendering = true;
				animate();
			}
		},

		animate: function () {
			requestAnimationFrame(this.animate.bind(this));
			controls.update();
		},

		render: function() {
			this.light.position.copy(this.camera.position).addScaledVector(this.camera.up, this.standardDistance);
			this.spotLight.position.copy(this.camera.position);
			glRenderer.render(glScene, this.camera);
			cssRenderer.render(cssScene, this.camera);
		},

		resetGroups: function () {
			// Remove labels and annotations
			this.labels = new Map();
			this.spheres = [];
			this.annotation3DObjects = new Map();

			if(this.labelGroup && this.annotationGlGroups) {

				for( var i = this.labelGroup.children.length - 1; i >= 0; i--) {
					this.labelGroup.remove(this.labelGroup.children[i]);
					cssScene.remove(this.labelGroup.children[i]);
				}

				for( var i = this.annotationGlGroups.children.length - 1; i >= 0; i--) {
					this.annotationGlGroups.remove(this.annotationGlGroups.children[i]);
					glScene.remove(this.annotationGlGroups.children[i]);
				}
			}
		},




		createPen() {
			// Nesting: Offset -> Orientation -> Object

			// Add physical pen model
			this.penGroupGLOffset = new THREE.Group();
			this.penGroupGLOffset.rotateX(-0.5 * Math.PI);

			this.penGroupGLOrientation = new THREE.Group();
			this.penGroupGLOffset.add(this.penGroupGLOrientation);
			this.penGroupGL = new THREE.Object3D();
			this.penGroupGLOrientation.add(this.penGroupGL);

			glScene.add(this.penGroupGLOffset);

			let penGeometry = new THREE.BoxBufferGeometry(
				0.4 * this.standardDistance,
				0.1 * this.standardDistance,
				0.1 * this.standardDistance
			);
			let penMaterial = new THREE.MeshStandardMaterial({
				side: THREE.DoubleSide,
				color: 0x333333,
				roughness: 0.75,
				metalness: 0.2
			});

			this.physicalPenModel = new THREE.Mesh( penGeometry, penMaterial );
			this.physicalPenSpotLight = new THREE.SpotLight( 0xffeedd, 1, 0, 0.5, 0.3, 2.0 );

			this.physicalPenModel.position.set(
				1.5 * this.standardDistance,
				// 0,
				0,
				0
			);
			const penAxisHelper = new THREE.AxisHelper(0.3 * this.standardDistance);
			penAxisHelper.position.copy(this.physicalPenModel.position);
			this.penGroupGL.add(penAxisHelper);
			this.physicalPenSpotLight.position.copy(this.physicalPenModel.position);
			this.penGroupGL.add( this.physicalPenModel );
			this.penGroupGL.add( this.physicalPenSpotLight );

			let center = new THREE.Vector3(0, 0, 0);
			this.physicalPenSpotLight.worldToLocal(center);
			this.physicalPenSpotLight.lookAt(center);
		},

		penStateChanged: function () {
			if (this.penGroupGLOrientation) {
				const quaternion = this.penState.quat.clone();
				this.penGroupGLOrientation.setRotationFromQuaternion(quaternion);

				this.mouseOrPenMoved();
				requestAnimationFrame(() => this.render());
			}
		},

		physicalModelStateChanged: function () {

			if (this.mainGroupGL) {
				const quaternion = this.physicalModelState.quat.clone();
				this.mainGroupGL.setRotationFromQuaternion(quaternion);
				this.mainGroupCSS.setRotationFromQuaternion(quaternion);
			}
		},

		attached: function() {
			this.modus = {modelGrabbing: false, hiddenLabels: false};


			let width = this.parentNode.getBoundingClientRect().width;
			let height = this.parentNode.getBoundingClientRect().height;
			this.standardDistance = 500;
			this.camera = new THREE.PerspectiveCamera(50, width / height, this.standardDistance / 100, this.standardDistance * 100);
			this.camera.position.set(
				2 * this.standardDistance,
				2 * this.standardDistance,
				2 * this.standardDistance
			);

			glRenderer = new THREE.WebGLRenderer({
				antialias: true,
				alpha: true
			});
			glRenderer.setClearColor(0x00ff00, 0.0);
			glRenderer.setSize(width, height);
			// QUESTION: when to do the following?
			//glRenderer.setPixelRatio(window.devicePixelRatio);
			glRenderer.shadowMapEnabled = true;

			// cssRenderer is used for font rendering
			cssRenderer = new THREE.CSS3DRenderer();
			cssRenderer.setSize(width, height);

			// let both renderers/canvases overlap
			glRenderer.domElement.style.position = 'absolute';
			glRenderer.domElement.style.top = 0;
			cssRenderer.domElement.style.position = 'absolute';
			cssRenderer.domElement.style.top = 0;


			this.meshMaterial = new THREE.MeshLambertMaterial({
				side: THREE.DoubleSide,
				color: 0x787878,
				roughness: 0.75,
				metalness: 0.02
			})

			this.atmosphericLight = new THREE.DirectionalLight(0x556677, 0.5);
			this.atmosphericLight.position.set(10 * this.standardDistance, 20 * this.standardDistance, -2.5 * this.standardDistance);

			this.atmosphericLight2 = new THREE.DirectionalLight(0x1166bb, 0.5);
			this.atmosphericLight2.position.set(-10 * this.standardDistance, 20 * this.standardDistance, 2.5 * this.standardDistance);

			// this.atmosphericLight3 = new THREE.DirectionalLight(0xff6600, 0.5);
			// this.atmosphericLight3.position.set(-10 * this.standardDistance, 20 * this.standardDistance, 2.5 * this.standardDistance);
			//
			// this.atmosphericLight4 = new THREE.DirectionalLight(0xff6600, 0.5);
			// this.atmosphericLight4.position.set(0, -10 * this.standardDistance, 0);

			this.light = new THREE.PointLight( 0xccddff, 1, 0 );
			this.spotLight = new THREE.SpotLight( 0xffddbb, 1, 0, 0.5, 1, 2.0 );

			// glScene.add(this.atmosphericLight);
			// glScene.add(this.light);
			glScene.add(this.spotLight);

			this.floorMaterial = new THREE.MeshStandardMaterial({
				color: 0xb9b9b9,
				transparent: true,
				opacity: 0.5,
				side: THREE.DoubleSide
			});
			this.floor = new THREE.Mesh(new THREE.PlaneBufferGeometry(this.standardDistance * 4, this.standardDistance * 4, 2, 2), this.floorMaterial);
			glScene.add(this.floor);
			console.log(this.floor.up);
			this.floor.rotateX(-0.5 * Math.PI);
			// console.log(this.floor.up);
			// setInterval(() => {
			// 	this.floor.rotateX(Math.random() * Math.PI);
			// 	this.floor.rotateX(Math.random() * Math.PI);
			// 	this.floor.rotateX(Math.random() * Math.PI);
			// 	console.log('localup:', JSON.stringify(this.floor.up));
			// 	let up2 = this.floor.up.clone();
			// 	this.floor.localToWorld(up2);
			// 	console.log('worldup:', JSON.stringify(up2));
			// 	this.render();
			// }, 100);
			// // console.log(this.floor.rotation.z);

			glRenderer.domElement.id = 'glRenderer';
			cssRenderer.domElement.id = 'cssRenderer';
			Polymer.dom(this.root).appendChild(glRenderer.domElement);
			Polymer.dom(this.root).appendChild(cssRenderer.domElement);

			if (this.labelGroup === undefined)
				this.labelGroup = new THREE.Object3D();
			if (this.annotationGlGroups === undefined)
				this.annotationGlGroups = new THREE.Object3D();

			this.createPen();

			//cssScene.add(this.labelGroup);
			//glScene.add(this.annotationGlGroups);
			this.resetGroups();

			// setup 3d-controls (rotating the camera with cursor)
			controls = new THREE.TrackballControls(this.camera, this);
			controls.rotateSpeed = 1.0;
			controls.zoomSpeed = 1.2;
			controls.panSpeed = 0.8;
			controls.noZoom = false;
			controls.noPan = false;
			controls.staticMoving = true;
			controls.dynamicDampingFactor = 0.3;
			controls.keys = [65, 83, 68];

			// add cursor pointer to 3D scene
			var sphereGeometry = new THREE.SphereGeometry( this.standardDistance / 45, 6, 6 );
			var sphereMaterial = new THREE.MeshLambertMaterial( {color: 0xff0000} );
			this.pointerSphere = new THREE.Mesh( sphereGeometry, sphereMaterial );
			glScene.add(this.pointerSphere);

			var axisHelper = new THREE.AxisHelper( this.standardDistance );
			glScene.add( axisHelper );

			// create Raycaster used for polygon editing tool
			this.raycaster = new THREE.Raycaster()

			controls.addEventListener('change', this.render.bind(this))
			controls.addEventListener('change', this.updateAllAnnotationVisibility.bind(this))
			controls.handleResize()

			// init annotations to empty array
			this.annotations = [];
			this.annotation3DObjects = new Map();
			this.hoveredAnnotation = null;

			this.annotationEditTimeout = undefined;

			this.resize();
			this.fire('initialized')
		},

		getPenPosition() {
			return this.penGroupGLOffset;
		},

		resize: function(event) {
			let width = this.parentNode.getBoundingClientRect().width;
			let height = this.parentNode.getBoundingClientRect().height;
			glRenderer.setSize(width, height);
			cssRenderer.setSize(width, height);
			this.camera.aspect = width / height;
			this.camera.updateProjectionMatrix();
			controls.handleResize();
			this.render();
		},

		_fileChanged: function () {
			console.log('fileChanged')
			console.log(this.file)

			this.resetGroups();
			this.annotations = [];

			// load the file and use it for display
			var loader = new THREE.STLLoader()
			var filepath = URL.createObjectURL(this.file)
			loader.load(filepath,
				geometry  => {
					const meshFromFile = new THREE.Mesh(geometry, this.meshMaterial);
					this.boundingBox = new THREE.Box3().setFromObject(meshFromFile);
					this.maxLength = Math.max(this.boundingBox.max.x, this.boundingBox.max.y, this.boundingBox.max.z);
					// TODO: Save scale factor in DB.
					meshFromFile.scale.set(this.standardDistance/this.maxLength, this.standardDistance/this.maxLength, this.standardDistance/this.maxLength);
					var height = this.boundingBox.size().y;
					var pos = glScene.position;


					// swap existing mesh with new mesh
					if (this.fileRepresentation !== undefined)
						this.mainGroupGL.remove(this.fileRepresentation);

					this.fileRepresentation = meshFromFile;


					this.mainGroupCSS = new THREE.Object3D();
					this.mainGroupGL = new THREE.Object3D();
					this.mainGroupGLOffset = new THREE.Group();
					this.mainGroupCSSOffset = new THREE.Group();

					this.mainGroupGLOffset.rotateX(-0.5 * Math.PI);
					this.mainGroupCSSOffset.rotateX(-0.5 * Math.PI);

					glScene.add(this.mainGroupGLOffset);
					glScene.add(this.mainGroupCSSOffset);

					this.mainGroupCSSOffset.add(this.mainGroupCSS);
					this.mainGroupGLOffset.add(this.mainGroupGL);

					// create group for text annotations in 3D
					if (this.labelGroup === undefined)
						this.labelGroup = new THREE.Object3D();
					if (this.annotationGlGroups === undefined)
						this.annotationGlGroups = new THREE.Object3D();

					let mainGroupAxisHelper = new THREE.AxisHelper( this.standardDistance );
					this.mainGroupGL.add(mainGroupAxisHelper)
					this.mainGroupCSS.add(this.labelGroup);
					this.mainGroupGL.add(this.annotationGlGroups);
					this.mainGroupGL.add(this.fileRepresentation);
					glScene.add(this.penGroupGLOffset);
					cssScene.add(this.mainGroupCSSOffset);


					this.render();
					this.animate();
				}
			);
		},

		_annotationsChanged: function(newAnnotations, oldAnnotations) {



			// debug output of annotations
			// first remove all previous annotations
			//
			// !!!IMPORTANT FIXME!!!: only update modified ones, instead of removing and completely re-creating
			//
			//
			let changedAnnotations = [];
			let addedAnnotations = [];
			let removedAnnotations = [];

			// Get changed and new annotations
			for (let newAnnotation of this.annotations) {
				let oldAnnotation = oldAnnotations.find(({_id}) => _id === newAnnotation._id);

				if(oldAnnotation && oldAnnotation._rev !== newAnnotation._rev) {
					// changd annotation
					changedAnnotations.push(newAnnotation)
				} else if (oldAnnotation === undefined) {
					// new annotation
					addedAnnotations.push(newAnnotation)
				}
			}

			// Get removed annotations
			removedAnnotations = oldAnnotations.filter((oldAnnotation) => {
				return this.annotations.find((annotation) => annotation._id === oldAnnotation._id) === undefined;
			}) || [];
			console.log('changedAnnotations', changedAnnotations);
			console.log('removedAnnotations', removedAnnotations);
			console.log('addedAnnotations', addedAnnotations);

			// Following part has to be async because the annotation-box-3d's may not ready yet in this tick.
			// Polymer.dom.flush();
			this.async(function() {

				// this.removeAnnotationObjects(removedAnnotations);
				// // For changed annotations, only remove the GL objects that are not created via dom-repeat
				// // and keep labels intact when an annotation is just changed
				// this.changeAnnotationObjects(changedAnnotations);
				//
				// for (let annotation of addedAnnotations) {
				// 	this.addAnnotationObject(annotation);
				// }


				// console.log(newAnnotations, oldAnnotations);
				this.resetGroups();
				for (let annotation of this.annotations) {
					this.addAnnotationObject(annotation);
				}


				this.render();
			});

		},


		removeAnnotationObjects: function (annotations) {
			for (let annotation of annotations) {
				let glGroup = this.annotation3DObjects.get(annotation._id).glGroup;
				this.annotationGlGroups.remove(glGroup);

				console.log('also remove the labels please!');
				let label = this.labels.get(annotation._id);
				console.log(label);
				this.labelGroup.remove(label);
				cssScene.remove(label);

				glScene.remove(glGroup);
			}
		},

		changeAnnotationObjects: function (annotations) {
			for (let annotation of annotations) {
				let glGroup = this.annotation3DObjects.get(annotation._id).glGroup;
				this.annotationGlGroups.remove(glGroup);

				console.log('also remove the labels please!');
				let label = this.labels.get(annotation._id);
				console.log(label);
				this.labelGroup.remove(label);
				cssScene.remove(label);

				glScene.remove(glGroup);
			}
		},

		addAnnotationObject: function (annotation) {
			let annotation3DObject = {};
			let annotationGlGroup = new THREE.Object3D();
			annotationGlGroup.userData = {_id: annotation._id};
			let multFactor = 2.0;

			let label = this.createLabel(annotation, multFactor);

			this.labels.set(annotation._id, label);
			this.labelGroup.add(label);
			annotation3DObject.label = label;

			// TODO: add arrow, label to a group/structure to be selectable
			let arrow = this.createArrow(annotation.position, label.position, annotation.statusColor);
			annotationGlGroup.add(arrow);
			annotation3DObject.arrow = arrow;


			let sphere = new THREE.Mesh(
				new THREE.SphereGeometry(this.standardDistance / 40, 6, 6),
				new THREE.MeshLambertMaterial({ color: 0xff0000})
			);
			sphere.position.copy(annotation.position);
			annotationGlGroup.add(sphere);
			annotation3DObject.sphere = sphere;
			this.spheres.push(sphere);




			// if annotation has polygon info, create it and add it to the scene
			if (annotation.polygon !== undefined) {
				let polygon = this.createPolygon(annotation.polygon, annotation.creatorProfile.color);
				annotationGlGroup.add(polygon)
				annotation3DObject.polygon = polygon
			}
			this.annotationGlGroups.add(annotationGlGroup);
			annotation3DObject.glGroup = annotationGlGroup;
			this.annotation3DObjects.set(annotation._id, annotation3DObject);
			return annotation3DObject;
		},
		_hoveredAnnotationChanged: function () {

		},

		updateAllAnnotationVisibility: function () {
			// TODO: there is a PR on threejs for raycasting in css renderer, use it once ready
			// triggered on controls update
			let raycaster = new THREE.Raycaster();
			if(this.modus.hiddenLabels) {
				// Hide all Annotations (except red pinpoint) by default
				// and conditionally unhide the hovered annotation
				// This is not super efficient (toggling all every time) but should suffice in this case
				// console.log(this.annotation3DObjects.values());
				for (let {label, arrow} of this.annotation3DObjects.values()) {
					label.element.style.display = 'none';
					label.element.style.opacity = 0.0;
					arrow.visible = false;
				}

				let visibleAnnotations = [];
				if(this.hoveredAnnotation) visibleAnnotations.push(this.hoveredAnnotation.userData);
				if(this.selectedAnnotation) visibleAnnotations.push(this.selectedAnnotation)
				for (let annotation of visibleAnnotations) {
					if(!annotation) continue;
					let {label, arrow} = this.annotation3DObjects.get(annotation._id);
					label.element.style.display = 'block';
					label.element.style.opacity = 0.8;
					arrow.visible = true;
				}

			}


			if (this.labelGroup.children === undefined) return

			for(let label of this.labelGroup.children) {
				let normalizedDirection = (label.position.clone().sub(this.camera.position)).normalize()
				raycaster.set(this.camera.position.clone(), normalizedDirection)
				raycaster.far = this.camera.position.distanceTo(label.position)
				let intersections = raycaster.intersectObject(this.fileRepresentation)
				if (intersections.length !== 0) {
					label.element.style.opacity = 0.0
				} else {
					label.element.style.opacity = 0.8
				}
			}

			this.render()

		},

		toggleTrack: function(e) {
			this.modus.modelGrabbing = !this.modus.modelGrabbing;
			Polymer.dom(this).classList.toggle('track');
		},

		updateMouse: function (mouseEvent) {
			let canvas = this.$$('canvas');
			this.mouse = new THREE.Vector2(
				(mouseEvent.layerX / canvas.width) * 2/*window.devicePixelRatio*/ - 1,
				-((mouseEvent.layerY / canvas.height) * 2/*window.devicePixelRatio*/ - 1)
			);
		},

		mouseOrPenMoved(event) {
			this.previousCameraPosition = controls.object.position.clone();
			this.previousCameraRotation = controls.object.rotation.clone();
			let sphereIntersections = [];

			let penActive = event === undefined;
			if (!penActive) {
				this.updateMouse(event);
			}

			// console.log(this.tool);

			if(this.modus.hiddenLabels || this.tool === 'edit') {
				this.raycaster.setFromCamera(this.mouse, this.camera);
				sphereIntersections = this.raycaster.intersectObjects(this.spheres);
				this.hoveredAnnotation = undefined;
				if(sphereIntersections.length !== 0) {
					// Get new hoveredAnnotation and make it visible
					this.hoveredAnnotation = sphereIntersections[0].object.parent;
				}
				// FIXME: update only on actual change
				this.updateAllAnnotationVisibility();
			}

			Polymer.dom(this).classList.remove('polygonCursor');
			Polymer.dom(this).classList.remove('fingerCursor');

			let intersections = [];
			if (this.fileRepresentation) {
				// console.log('tool',this.tool);
				if (!penActive && (this.tool === 'polygon' || this.tool === 'point' || this.tool === 'edit')) {
					this.raycaster.setFromCamera(this.mouse, this.camera);
					console.log('use camera for raycaster');
				} else if(penActive) {
					// console.log('use pen position for raycaster');
					const origin = this.physicalPenModel.getWorldPosition();
					const normalizedDirection = origin.clone().negate().normalize();
					this.raycaster.set(origin, normalizedDirection);
				}
				if(penActive || this.tool !== 'rotate') {
					intersections = this.raycaster.intersectObject(this.fileRepresentation);
				}
			}

			if (intersections.length !== 0 || sphereIntersections.length !== 0) {

				if (this.modus.modelGrabbing && this.tool !== 'rotate') {
					if(this.hoveredAnnotation && this.tool === 'edit') {
						Polymer.dom(this).classList.add('fingerCursor');
					} else {
						Polymer.dom(this).classList.add('polygonCursor');
					}

				}
				this.spotLight.target = this.pointerSphere;
				if(intersections.length !== 0) this.pointerSphere.position.set(intersections[0].point.x, intersections[0].point.y , intersections[0].point.z);
				this.render();

			} else {

			}

		},

		keydown: function (e) {
			if (e.defaultPrevented) {
				return; // Should do nothing if the key event was already consumed.
			}

			switch (e.which) {
				case 13: /*Enter*/
					if (this.tool === 'polygon' && this.verticesPolygonTool.length !== 0){
						event.preventDefault();
						// TODO: finish shape and create annotation
						this.fire('create-annotation', {
							description: '',
							polygon: this.verticesPolygonTool,
							position: this.verticesPolygonTool[0],
							cameraPosition: controls.object.position.clone(),
							// cameraRotation: camera.rotation,
							cameraUp: this.camera.up
						});
						if (this.previewAnnotation !== undefined) {
							this.mainGroupGL.remove(this.previewAnnotation.arrow);
							this.mainGroupGL.remove(this.previewAnnotation.polygon);
							this.mainGroupCSS.remove(this.previewAnnotation.label);
							this.previewAnnotation = undefined;
						}
						glScene.remove(this.previewPolygon);
						this.previewPolygon = undefined;
						this.verticesPolygonTool = [];
						console.log('added polygon annotation');
					}
					break;
					case 27 /* Escape */:
						console.log(this.previewAnnotation);
						if (this.previewPolygon !== undefined){
							glScene.remove(this.previewPolygon);
							this.previewPolygon = undefined;
						}

						if(this.previewAnnotation !== undefined) {
							// Remove preview annotation
							this.annotationGlGroups.remove(this.previewAnnotation.glGroup);
							this.labelGroup.remove(this.previewAnnotation.label);
							this.previewAnnotation = undefined;
						}

						this.verticesPolygonTool = [];
						requestAnimationFrame(this.render.bind(this));
					break;
				default:

					break;
			}
		},

		track: function (e) {
			controls.enabled = true;
			if(this.tool === 'edit') {
				controls.enabled = false;
				if(this.hoveredAnnotation) {
					let newPosition = this.pointerSphere.position.clone();
					this.mainGroupGL.worldToLocal(newPosition);
					let id = this.hoveredAnnotation.userData._id;
					clearTimeout(this.annotationEditTimeout);
					this.annotationEditTimeout = setTimeout(() => {
						this.fire('edit-annotation',
							{temporary, newAnnotation: {_id: id, position: newPosition,}, elem: this});
					}, 4000);


					let targetAnnotation = this.annotations.filter(({_id}) => _id === id)[0];
					targetAnnotation.position = newPosition;
					console.log(targetAnnotation.position);
					this.removeAnnotationObjects([targetAnnotation]);
					this.addAnnotationObject(targetAnnotation);


				}
			}
		},
		tap: function(e) {

			if (jsonEqual(this.previousCameraPosition, this.camera.position) === false || jsonEqual(this.previousCameraRotation, this.camera.rotation) == false) {
				console.log('moved! return!');
			}

			// Update values for: this.mouse
			this.updateMouse(e.detail.sourceEvent);

			// update the picking ray with the camera and mouse position
			this.fileRepresentation.updateMatrixWorld()
			this.raycaster.setFromCamera(this.mouse, this.camera);

			// Calculate objects intersecting the picking ray
			// only use the first/frontmost intersection  -> [0]
			var intersections = this.raycaster.intersectObject(this.fileRepresentation);
			var intersection = ( intersections.length ) > 0 ? intersections[ 0 ] : null;
			// Transform intersection point from world coordinates
			// to the local coordinate space of the mainGroupGL/mainGroupCSS (both equival. matrix)


			var localIntersectionPoint;
			var localCameraPosition;
			if(intersection) {
				var localIntersectionPoint = intersection.point.clone();
				var localCameraPosition = controls.object.position.clone();

				this.mainGroupGL.worldToLocal(localIntersectionPoint);
				this.mainGroupGL.worldToLocal(localCameraPosition);
			}

			console.log(localIntersectionPoint);


			switch (this.tool) {

				case 'point':

						event.preventDefault();
						// TODO: finish shape and create annotation
						this.fire('create-annotation', {
							description: '',
							polygon: [localIntersectionPoint.clone()],
							position: localIntersectionPoint.clone(),
							cameraPosition: controls.object.position.clone(),
							// cameraRotation: camera.rotation,
							cameraUp: controls.object.up
						});
						if (this.previewAnnotation !== undefined) {
							this.mainGroupGL.remove(this.previewAnnotation.arrow);
							this.mainGroupGL.remove(this.previewAnnotation.polygon);
							this.mainGroupCSS.remove(this.previewAnnotation.label);
							this.previewAnnotation = undefined;
						}
						glScene.remove(this.previewPolygon);
						this.previewPolygon = undefined;
						this.verticesPolygonTool = [];
						console.log('added polygon annotation');

					break;
				case 'edit':

				break;
				case 'polygon':
					this.verticesPolygonTool.push(localIntersectionPoint.clone());

					// create new preview polygon/shape when enough points are available
					if (this.verticesPolygonTool.length >= 3) {
							glScene.remove(this.previewPolygon);
							this.previewPolygon = this.createPolygon(this.verticesPolygonTool, 0x00ff00);
							glScene.add(this.previewPolygon);
					}

					// And show a temporary preview annotation if first tap.
					if (this.previewAnnotation === undefined) {
						this.previewAnnotation = this.addAnnotationObject({
							_id: 'previewAnnotation',
							status: 'comment',
							statusColor: 'blue',
							description: "Press Enter to edit/create. Esc to cancel.",
							position: localIntersectionPoint.clone(),
							cameraPosition: controls.object.position.clone(),
							cameraUp: this.camera.up
						});
					}

					this.render();
				break;

				case 'setCamera':
					console.log(this.camera.quaternion, this.camera.position, this.camera.up);
					this.resetCamera = this.camera.clone();

				break;

				case 'resetCamera':
					console.log(this.camera.quaternion, this.camera.position, this.camera.up);
					this.camera.quaternion.copy(this.resetCamera.quaternion);
					this.camera.position.copy(this.resetCamera.position);
					this.camera.up.copy(this.resetCamera.up);

				break;

				case 'bottom':
					// HACK: for testing
					//
					let normals = this.fileRepresentation.geometry.getAttribute('normal').array;
					let faces = this.fileRepresentation.geometry.getAttribute('normal').array;
					console.log(this.fileRepresentation.geometry);
					let localIntersection = new THREE.Object3D();

					localIntersection.position.copy(intersection.point);
					this.mainGroupGL.add(localIntersection);

					let bottomNormal = new THREE.Vector3(
						normals[(intersection.faceIndex*3)],
						normals[(intersection.faceIndex*3) + 1],
						normals[(intersection.faceIndex*3) + 2]
					);

					// console.log(this.fileRepresentation.geometry.getAttribute('faces'));
					let face = new THREE.Face3(
						faces[(intersection.faceIndex*3)],
						faces[(intersection.faceIndex*3) + 1],
						faces[(intersection.faceIndex*3) + 2]
					);


					this.mainGroupGL.quaternion.setFromUnitVectors(bottomNormal, new THREE.Vector3(0, -1, 0));
					this.mainGroupGL.updateMatrixWorld();
					this.mainGroupGL.updateMatrix();
					localIntersection.updateMatrix();
					localIntersection.updateMatrixWorld();

					// TODO: Rotation works. Position has yet to be done correctly!

					// console.log(localIntersection.getWorldPosition(), localIntersection.position);
					// let dist = localIntersection.position.distanceTo(this.floor.position);
					// if(localIntersection.position.y > 0) {
					// 	console.log('tiefer bringen');
					// 	this.mainGroupGL.position.y -= dist;
					// } else {
					// 	console.log('h√∂her bringen');
					// 	this.mainGroupGL.position.y += dist;
					// }

					this.render();





					// this.mainGroupGL.position.sub(norm);

				break;
				default:
			}
		},

		createPolygon: function (vertices, color) {
			// IDEA: move to helper object?
			let polygon = new THREE.Geometry();
			polygon.vertices = vertices;

			// calculate faces of preview polygon
			for (var i = 1; i < polygon.vertices.length - 1; i++) {
				polygon.faces.push( new THREE.Face3( 0, i, i+1 ) )
			}
			return new THREE.Mesh(
				polygon,
				new THREE.MeshBasicMaterial( {
					color: color,
					side: THREE.DoubleSide
				} )
			);
		},

		createLabel: function (annotation, multFactor) {
			// let div = document.createElement('annotation-box-3d');
			// let div = document.createElement('div');
			// let textElement = document.createElement('span');

			// div.annotation = annotation;
			Polymer.dom.flush();
			let div = this.$$(`#annotationbox3d_${CSS.escape(annotation._id)}`);


			// TODO: disable any raycaster stuff etc. when interacting with label

			// div.addEventListener('mouseover', () => {
			// 	this.fire('label-over', annotation._id);
			// });
			// div.addEventListener('mouseout', () => {
			// 	this.fire('label-out', annotation._id);
			// });

			let label = new THREE.CSS3DSprite(div);
			label.userData.div = div;

			if (annotation.cameraPosition !== undefined) {
				// Convert x,y,z object into Vector3 object.
				let camPos = new THREE.Vector3(annotation.cameraPosition.x, annotation.cameraPosition.y, annotation.cameraPosition.z);
				let labelPos = this.mainGroupGL.worldToLocal(camPos);
				label.position.copy(labelPos).multiplyScalar(0.6);
			} else {
				label.position.set(annotation.position.x, annotation.position.y, annotation.position.z);
				label.position.multiplyScalar(multFactor);
			}
			return label;
		},

		createArrow: function (point, labelpos, color) {
			var material = new THREE.LineBasicMaterial({
				color: color
			})

			var geometry = new THREE.Geometry()
			geometry.vertices.push(
				point,
				labelpos
			)

			return new THREE.Line( geometry, material )
		},

		_toolChanged: function(e) {
			// this is render-view's event listener on the toolBox
			// when a different tool is selected, this function is triggered
			console.log('tool changed.');
			//do some cleanup/inits
			glScene.remove(this.previewPolygon);
			this.previewPolygon = undefined;
			this.verticesPolygonTool = [];

			switch (this.tool) {
				case 'rotate': this.modus.modelGrabbing = true;
					break;
				default:
					break;
			}
		},
		_selectedAnnotationChanged: function () {

		},
		focusAnnotation: function (annotation) {
			if (annotation.cameraPosition !== undefined) {
				// The resetFrom function was added by me (modified .reset()) to allow
				// reset from a saved position (eg. stored in the DB)
				controls.resetFrom(annotation.cameraPosition, annotation.cameraUp);
			} else {
				return;
			}
		}
	})
	</script>

</dom-module>
