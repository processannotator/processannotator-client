<script src="../libs/three/three.min.js"></script>
<script src="../libs/three/controls/TrackballControls.js"></script>
<script src="../libs/three/renderers/CSS3DRenderer.js"></script>
<script src="../libs/three/loaders/STLLoader.js"></script>

<dom-module id="render-view">

	<template>
		<style is="custom-style">
			:host {
				margin: 0;
				cursor: -webkit-grab;
				min-height: 100%;
				min-width: 100%;
			}

			:host.track {
				cursor: -webkit-grabbing;
			}

			:host:hover {}

			canvas {
				width: 100%;
				height: 100%;
			}

			:host.polygonCursor {
				cursor: crosshair;
			}
		</style>
	</template>

	<script>
	'use strict' /*eslint global-strict:0*/

	// FIXME: shouldnt those global variables better reside inside the element
	// vis this.glRenderer = ...

	var glScene = new THREE.Scene();
	var cssScene = new THREE.Scene();
	var controls;
	var cssObject;
	var glRenderer;
	var cssRenderer;
	var render;
	var animate;

	function jsonEqual(a,b) {
    return JSON.stringify(a) === JSON.stringify(b);
	}

	Polymer({
		is: "render-view",

		properties: {
			fileRepresentation: Object,
			file: {
				type: Object,
				observer: '_fileChanged'
			},
			tool: {
				type: 'Object',
				observer: '_toolChanged'
			},
			annotations: {
				type: Array,
				observer: "_annotationsChanged"
			},
			labels: {
				type: Map
			},
			physicalModelState: {
				type: Object,
				observer: "physicalModelStateChanged"
			}
		},

		listeners: {
			'tap': 'tap',
			'up': 'toggleTrack',
			'down': 'toggleTrack',
			'track': 'track',
			'mousemove': 'mouseOrPenMoved'
		},

		ready: function() {
			// doesnt work with listeners on this very element
			// so create start event listener
			console.log('renderview ready');
			this.ready = true;
			this.rendering = false;
			document.addEventListener('keydown', this.keydown.bind(this));
		},

		startRendering: function() {
			if (this.rendering === false) {
				console.log('started rendering');
				this.rendering = true;
				animate();
			}
		},

		animate: function () {
			requestAnimationFrame(this.animate.bind(this));
			this.light.position.copy(this.camera.position).addScaledVector(this.camera.up, this.standardDistance);
			this.spotLight.position.copy(this.camera.position);

			controls.update();
		},

		render: function() {
			glRenderer.render(glScene, this.camera);
			cssRenderer.render(cssScene, this.camera);
		},

		resetGroups: function () {
			// Remove labels and annotations
			this.labels = new Map();
			if(this.labelGroup && this.annotationGlGroups) {
				
				for( var i = this.labelGroup.children.length - 1; i >= 0; i--) {
					this.labelGroup.remove(this.labelGroup.children[i]);
					cssScene.remove(this.labelGroup.children[i]);
				}

				for( var i = this.annotationGlGroups.children.length - 1; i >= 0; i--) {
					this.annotationGlGroups.remove(this.annotationGlGroups.children[i]);
					cssScene.remove(this.annotationGlGroups.children[i]);
				}
			}

		},

		createPen() {
			// Nesting: Offset -> Orientation -> Object

			// Add physical pen model
			this.penGroupGLOffset = new THREE.Group();
			this.penGroupGLOffset.rotateX(-0.5 * Math.PI);
			this.penGroupGLOrientation = new THREE.Group();
			this.penGroupGLOffset.add(this.penGroupGLOrientation);
			this.penGroupGL = new THREE.Object3D();
			this.penGroupGLOrientation.add(this.penGroupGL);

			glScene.add(this.penGroupGLOffset);
			let penGeometry = new THREE.BoxBufferGeometry(
				0.4 * this.standardDistance,
				0.1 * this.standardDistance,
				0.1 * this.standardDistance
			);
			let penMaterial = new THREE.MeshStandardMaterial({
				side: THREE.DoubleSide,
				color: 0x333333,
				roughness: 0.75,
				metalness: 0.2
			});

			this.physicalPenModel = new THREE.Mesh( penGeometry, penMaterial );
			this.physicalPenSpotLight = new THREE.SpotLight( 0xffeedd, 1, 0, 0.5, 0.3, 2.0 );

			this.physicalPenModel.position.set(
				1.5 * this.standardDistance,
				// 0,
				0,
				0
			);
			const penAxisHelper = new THREE.AxisHelper(0.3 * this.standardDistance);
			penAxisHelper.position.copy(this.physicalPenModel.position);
			this.penGroupGL.add(penAxisHelper);
			this.physicalPenSpotLight.position.copy(this.physicalPenModel.position);
			this.penGroupGL.add( this.physicalPenModel );
			this.penGroupGL.add( this.physicalPenSpotLight );

			let center = new THREE.Vector3(0, 0, 0);
			this.physicalPenSpotLight.worldToLocal(center);
			this.physicalPenSpotLight.lookAt(center);
		},

		physicalModelStateChanged: function () {
			if (this.penGroupGLOrientation) {
				// TODO Use quaternion instead of euler
				// const rotation = new THREE.Quaternion().setFromEuler(new THREE.Euler(-Math.PI, 0, 0));
				const quaternion = this.physicalModelState.quat.clone();//.multiply(rotation);
				// if (this.fileRepresentation) {
				// 	this.fileRepresentation.setRotationFromQuaternion(quaternion);
				// }
				this.penGroupGLOrientation.setRotationFromQuaternion(quaternion);
				this.mouseOrPenMoved();
				requestAnimationFrame(() => this.render());
				// this.render();
			}
		},

		attached: function() {

			this.modus = {modelGrabbing: false};

			let width = this.parentNode.getBoundingClientRect().width;
			let height = this.parentNode.getBoundingClientRect().height;
			this.standardDistance = 500;
			this.camera = new THREE.PerspectiveCamera(50, width / height, this.standardDistance / 100, this.standardDistance * 100);
			this.camera.position.set(
				2 * this.standardDistance,
				2 * this.standardDistance,
				2 * this.standardDistance
			);

			glRenderer = new THREE.WebGLRenderer({
				antialias: false,
				alpha: true
			});
			glRenderer.setClearColor(0x00ff00, 0.0);
			glRenderer.setSize(width, height);
			glRenderer.shadowMapEnabled = true;

			// cssRenderer is used for font rendering
			cssRenderer = new THREE.CSS3DRenderer();
			cssRenderer.setSize(width, height);

			// let both renderers/canvases overlap
			glRenderer.domElement.style.position = 'absolute';
			glRenderer.domElement.style.top = 0;
			cssRenderer.domElement.style.position = 'absolute';
			cssRenderer.domElement.style.top = 0;


			this.meshMaterial = new THREE.MeshLambertMaterial({
				side: THREE.DoubleSide,
				color: 0x787878,
				roughness: 0.75,
				metalness: 0.02
			})

			this.atmosphericLight = new THREE.DirectionalLight( 0x336699, 0.5);
			this.atmosphericLight.castShadow = true;
			this.atmosphericLight.shadowDarkness = 0.5;
			this.atmosphericLight.shadowMapSoft = true;
			this.atmosphericLight.shadowMapWidth = 1024;
			this.atmosphericLight.shadowMapHeight = 1024
			this.atmosphericLight.position.set(5 * this.standardDistance, 10 * this.standardDistance, -2.5 * this.standardDistance);

			this.atmosphericLight2 = new THREE.DirectionalLight( 0x336699, 0.5);
			this.atmosphericLight2.castShadow = true;
			this.atmosphericLight2.shadowDarkness = 0.5;
			this.atmosphericLight2.shadowMapSoft = true;
			this.atmosphericLight2.shadowMapWidth = 1024;
			this.atmosphericLight2.shadowMapHeight = 1024
			this.atmosphericLight2.position.set(-5 * this.standardDistance, 10 * this.standardDistance, 2.5 * this.standardDistance);

			this.light = new THREE.PointLight( 0xffeedd, 1, 0 );
			this.spotLight = new THREE.SpotLight( 0xffddbb, 1, 0, 0.5, 1, 2.0 );

			glScene.add(this.atmosphericLight);
			glScene.add(this.light);
			glScene.add(this.spotLight);

			glRenderer.domElement.id = 'glRenderer';
			cssRenderer.domElement.id = 'cssRenderer';
			Polymer.dom(this.root).appendChild(glRenderer.domElement);
			Polymer.dom(this.root).appendChild(cssRenderer.domElement);

			if (this.labelGroup === undefined)
				this.labelGroup = new THREE.Object3D();
			if (this.annotationGlGroups === undefined)
				this.annotationGlGroups = new THREE.Object3D();

			this.createPen();

			//cssScene.add(this.labelGroup);
			//glScene.add(this.annotationGlGroups);
			this.resetGroups();

			// setup 3d-controls (rotating the camera with cursor)
			controls = new THREE.TrackballControls(this.camera, this);
			controls.rotateSpeed = 1.0;
			controls.zoomSpeed = 1.2;
			controls.panSpeed = 0.8;
			controls.noZoom = false;
			controls.noPan = false;
			controls.staticMoving = true;
			controls.dynamicDampingFactor = 0.3;
			controls.keys = [65, 83, 68];

			// add cursor pointer to 3D scene
			var sphereGeometry = new THREE.SphereGeometry( this.standardDistance / 45, 6, 6 );
			var sphereMaterial = new THREE.MeshLambertMaterial( {color: 0xff0000} );
			this.pointerSphere = new THREE.Mesh( sphereGeometry, sphereMaterial );
			glScene.add(this.pointerSphere);

			var axisHelper = new THREE.AxisHelper( this.standardDistance );
			glScene.add( axisHelper );

			// create Raycaster used for polygon editing tool
			this.raycaster = new THREE.Raycaster()

			controls.addEventListener('change', this.render.bind(this))
			controls.addEventListener('change', this.updateAnnotationVisibility.bind(this))
			controls.handleResize()

			// init annotations to empty array
			this.annotations = [];
			this.annotation3DObjects = [];

			this.fire('initialized')
		},

		getPenPosition() {
			return this.penGroupGLOffset;
		},

		resize: function(event) {
			let width = this.parentNode.getBoundingClientRect().width;
			let height = this.parentNode.getBoundingClientRect().height;
			glRenderer.setSize(width, height);
			cssRenderer.setSize(width, height);
			this.camera.aspect = width / height;
			this.camera.updateProjectionMatrix();
			controls.handleResize();
			this.render();
		},

		_fileChanged: function () {
			console.log('fileChanged')
			console.log(this.file)

			this.resetGroups();
			this.annotations = [];

			// load the file and use it for display
			var loader = new THREE.STLLoader()
			var filepath = URL.createObjectURL(this.file)
			loader.load(filepath,
				geometry  => {
					const meshFromFile = new THREE.Mesh(geometry, this.meshMaterial);
					meshFromFile.castShadow = true;
					meshFromFile.receiveShadow = true;
					this.boundingBox = new THREE.Box3().setFromObject(meshFromFile);
					this.maxLength = Math.max(this.boundingBox.max.x, this.boundingBox.max.y, this.boundingBox.max.z);
					// TODO: Save scale factor in DB.
					meshFromFile.scale.set(this.standardDistance/this.maxLength, this.standardDistance/this.maxLength, this.standardDistance/this.maxLength);
					var height = this.boundingBox.size().y;
					var pos = glScene.position;


					// swap existing mesh with new mesh
					if (this.fileRepresentation !== undefined)
						this.mainGroupGL.remove(this.fileRepresentation);

					this.fileRepresentation = meshFromFile;
					this.mainGroupCSS = new THREE.Object3D();
					this.mainGroupGL = new THREE.Object3D();


					// create group for text annotations in 3D
					if (this.labelGroup === undefined)
						this.labelGroup = new THREE.Object3D();
					if (this.annotationGlGroups === undefined)
						this.annotationGlGroups = new THREE.Object3D();

					this.mainGroupCSS.add(this.labelGroup);
					this.mainGroupGL.add(this.annotationGlGroups);
					this.mainGroupGL.add(this.fileRepresentation);
					glScene.add(this.mainGroupGL);
					glScene.add(this.penGroupGLOffset);
					cssScene.add(this.mainGroupCSS);

					this.render();
					this.animate();
				}
			);
		},

		_annotationsChanged: function() {
			console.log('_annotationsChanged');
			// debug output of annotations
			// first remove all previous annotations
			// FIXME: only update modified ones, instead of removing and completely re-creating
			this.resetGroups();

			for (let annotation of this.annotations) {
				this.addAnnotationObject(annotation);
			}

			this.render();
		},

		addAnnotationObject: function (annotation) {
			let annotation3DObject = {};
			let annotationGlGroup = new THREE.Object3D();
			let multFactor = 2;
			let label = this.createLabel(annotation, multFactor);

			this.labels.set(annotation._id, label);
			this.labelGroup.add(label);
			annotation3DObject.label = label;

			// TODO: add arrow, label to a group/structure to be selectable
			let arrow = this.createArrow(annotation.position, label.position, annotation.statusColor);
			annotationGlGroup.add(arrow);


			let sphere = new THREE.Mesh(
				new THREE.SphereGeometry(this.standardDistance / 100, 6, 6),
				new THREE.MeshLambertMaterial({ color: 0xff0000})
			);
			sphere.position.copy(annotation.position);
			annotationGlGroup.add(sphere);

			annotation3DObject.arrow = arrow;

			// if annotation has polygon info, create it and add it to the scene
			if (annotation.polygon !== undefined) {
				let polygon = this.createPolygon(annotation.polygon, annotation.creatorProfile.color);
				annotationGlGroup.add(polygon)
				annotation3DObject.polygon = polygon
			}
			this.annotationGlGroups.add(annotationGlGroup);
			annotation3DObject.glGroup = annotationGlGroup;
			this.annotation3DObjects.push(annotation3DObject);
			return annotation3DObject;
		},

		updateAnnotationVisibility: function () {
			// TODO: there is a PR on threejs for raycasting in css renderer, use it once ready
			// triggered on controls update
			let raycaster = new THREE.Raycaster()

			if (this.labelGroup.children === undefined) return

			for(let label of this.labelGroup.children) {
				let normalizedDirection = (label.position.clone().sub(this.camera.position)).normalize()
				raycaster.set(this.camera.position.clone(), normalizedDirection)
				raycaster.far = this.camera.position.distanceTo(label.position)
				let intersections = raycaster.intersectObject(this.fileRepresentation)
				if (intersections.length !== 0) {
					label.element.style.opacity = 0.0
				} else {
					label.element.style.opacity = 0.8
				}
			}
			this.render()

		},

		toggleTrack: function(e) {
			this.modus.modelGrabbing = !this.modus.modelGrabbing;
			Polymer.dom(this).classList.toggle('track');
		},

		updateMouse: function (mouseEvent) {
			let canvas = this.$$('canvas');
			this.mouse = new THREE.Vector2(
				(mouseEvent.layerX / canvas.width) * 2 - 1,
				-((mouseEvent.layerY / canvas.height) * 2 - 1)
			);
		},
		
		mouseOrPenMoved(event) {
			this.previousCameraPosition = controls.object.position.clone();
			this.previousCameraRotation = controls.object.rotation.clone();
			
			if (event) {
				this.updateMouse(event);
			}
			
			let intersections = [];
			
			if (this.fileRepresentation) {
				if (this.tool === 'polygon' || this.tool === 'brush') {
					this.raycaster.setFromCamera(this.mouse, this.camera);
				} else {
					const origin = this.physicalPenModel.getWorldPosition();
					const normalizedDirection = origin.clone().negate().normalize();
					this.raycaster.set(origin, normalizedDirection);
				}
				intersections = this.raycaster.intersectObject(this.fileRepresentation);
			}
			
			if (intersections.length !== 0) {
				if (this.modus.modelGrabbing === false) {
					Polymer.dom(this).classList.add('polygonCursor');
				}
				this.spotLight.target = this.pointerSphere;
				this.pointerSphere.position.set(intersections[0].point.x, intersections[0].point.y , intersections[0].point.z);
				this.render();
			} else {
				Polymer.dom(this).classList.remove('polygonCursor')
			}
			
		},

		keydown: function (e) {
			if (e.defaultPrevented) {
				return; // Should do nothing if the key event was already consumed.
			}
			
			switch (e.which) {
				case 13: /*Enter*/
					console.log('pressed enter');
					if (this.tool === 'polygon' && this.verticesPolygonTool.length !== 0){
						event.preventDefault();
						// TODO: finish shape and create annotation
						this.fire('create-annotation', {
							description: '',
							polygon: this.verticesPolygonTool,
							position: this.verticesPolygonTool[0],
							cameraPosition: controls.object.position.clone(),
							// cameraRotation: camera.rotation,
							cameraUp: this.camera.up
						});
						if (this.previewAnnotation !== undefined) {
							this.mainGroupGL.remove(this.previewAnnotation.arrow);
							this.mainGroupGL.remove(this.previewAnnotation.polygon);
							this.mainGroupCSS.remove(this.previewAnnotation.label);
							this.previewAnnotation = undefined;
						}
						glScene.remove(this.previewPolygon);
						this.previewPolygon = undefined;
						this.verticesPolygonTool = [];
						console.log('added polygon annotation');
					}
					break;
					case 27 /* Escape */:
						console.log(this.previewAnnotation);
						if (this.previewPolygon !== undefined){
							glScene.remove(this.previewPolygon);
							this.previewPolygon = undefined;
						}

						if(this.previewAnnotation !== undefined) {
							// Remove preview annotation
							this.annotationGlGroups.remove(this.previewAnnotation.glGroup);
							this.labelGroup.remove(this.previewAnnotation.label);
							this.previewAnnotation = undefined;
						}

						this.verticesPolygonTool = [];
						requestAnimationFrame(this.render.bind(this));
					break;
				default:

					break;
			}
		},
		track: function (e) {

		},
		tap: function(e) {

			if (jsonEqual(this.previousCameraPosition, this.camera.position) === false || jsonEqual(this.previousCameraRotation, this.camera.rotation) == false) {
				console.log('moved! return!');
			}

			// Update values for: this.mouse
			this.updateMouse(e.detail.sourceEvent);

			// update the picking ray with the camera and mouse position
			this.fileRepresentation.updateMatrixWorld()
			this.raycaster.setFromCamera(this.mouse, this.camera);

			// Calculate objects intersecting the picking ray
			// only use the first/frontmost intersection  -> [0]
			const intersections = this.raycaster.intersectObject(this.fileRepresentation);
			const intersection = ( intersections.length ) > 0 ? intersections[ 0 ] : null;
			// Transform intersection point from world coordinates
			// to the local coordinate space of the mainGroupGL/mainGroupCSS (both equival. matrix)
			this.mainGroupGL.worldToLocal(intersection.point);

			switch (this.tool) {

				case 'freehand':

						event.preventDefault();
						// TODO: finish shape and create annotation
						this.fire('create-annotation', {
							description: '',
							polygon: [intersection.point.clone()],
							position: intersection.point.clone(),
							cameraPosition: controls.object.position.clone(),
							// cameraRotation: camera.rotation,
							cameraUp: this.camera.up
						});
						if (this.previewAnnotation !== undefined) {
							this.mainGroupGL.remove(this.previewAnnotation.arrow);
							this.mainGroupGL.remove(this.previewAnnotation.polygon);
							this.mainGroupCSS.remove(this.previewAnnotation.label);
							this.previewAnnotation = undefined;
						}
						glScene.remove(this.previewPolygon);
						this.previewPolygon = undefined;
						this.verticesPolygonTool = [];
						console.log('added polygon annotation');

					break;

				case 'polygon':
					this.verticesPolygonTool.push(intersection.point.clone());

					// create new preview polygon/shape when enough points are available
					if (this.verticesPolygonTool.length >= 3) {
							glScene.remove(this.previewPolygon);
							this.previewPolygon = this.createPolygon(this.verticesPolygonTool, 0x00ff00);
							glScene.add(this.previewPolygon);
					}

					// And show a temporary preview annotation if first tap.
					if (this.previewAnnotation === undefined) {
						this.previewAnnotation = this.addAnnotationObject({
							_id: 'previewAnnotation',
							description: "Press Enter to edit/create. Esc to cancel.",
							position: intersection.point.clone(),
							cameraPosition: controls.object.position.clone(),
							cameraUp: this.camera.up
						});
					}

					this.render();
				break;
				default:
			}
		},

		createPolygon: function (vertices, color) {
			// IDEA: move to helper object?
			let polygon = new THREE.Geometry();
			polygon.vertices = vertices;

			// calculate faces of preview polygon
			for (var i = 1; i < polygon.vertices.length - 1; i++) {
				polygon.faces.push( new THREE.Face3( 0, i, i+1 ) )
			}
			return new THREE.Mesh(
				polygon,
				new THREE.MeshBasicMaterial( {
					color: color,
					side: THREE.DoubleSide
				} )
			);
		},

		createLabel: function (annotation, multFactor) {
			let div = document.createElement('div');
			let textElement = document.createElement('span');
			div.style.opacity = '0.85';
			div.style.fontSize = '30px';
			div.style.padding = "0.35em";
			div.style.background = "rgb(255, 255, 255)";
			div.style.border = annotation.statusColor + " solid 0.125em";
			div.style.transition = "opacity 0.5s";
			div.innerHTML = annotation.description;
			// div.addEventListener('mouseover', () => {
			// 	this.fire('label-over', annotation._id);
			// });
			// div.addEventListener('mouseout', () => {
			// 	this.fire('label-out', annotation._id);
			// });

			let label = new THREE.CSS3DSprite(div);
			label.userData.div = div;

			if (annotation.cameraPosition !== undefined) {
				// Convert x,y,z object into Vector3 object.
				let camPos = new THREE.Vector3(annotation.cameraPosition.x, annotation.cameraPosition.y, annotation.cameraPosition.z);
				label.position.copy(annotation.cameraPosition).multiplyScalar(0.6);
			} else {
				label.position.set(annotation.position.x, annotation.position.y, annotation.position.z);
				label.position.multiplyScalar(multFactor);
			}
			return label;
		},

		createArrow: function (point, labelpos, color) {
			var material = new THREE.LineBasicMaterial({
				color: color
			})

			var geometry = new THREE.Geometry()
			geometry.vertices.push(
				point,
				labelpos
			)

			return new THREE.Line( geometry, material )
		},

		_toolChanged: function(e) {
			// this is render-view's event listener on the toolBox
			// when a different tool is selected, this function is triggered
			console.log('tool changed.');
			//do some cleanup/inits
			glScene.remove(this.previewPolygon);
			this.previewPolygon = undefined;
			this.verticesPolygonTool = [];

			switch (this.tool) {
				case 'polygon':
					break;
				default:
					break;
			}
		},
		focusAnnotation: function (annotation) {
			if (annotation.cameraPosition !== undefined) {
				// The resetFrom function was added by me (modified .reset()) to allow
				// reset from a saved position (eg. stored in the DB)
				controls.resetFrom(annotation.cameraPosition, annotation.cameraUp);
			} else {
				return;
			}
		}
	})
	</script>

</dom-module>
