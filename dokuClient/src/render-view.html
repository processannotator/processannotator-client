<!DOCTYPE html>

<link rel="import" href="a-annotation.html">


<dom-module id="render-view">

	<template>
		<style is="custom-style">


			:host {
				margin: 0;
				width: 100%;
				height: 100%;
			}

			/*#canvas {
				width: 100%;
				height: 100%;
			}*/
			a-scene {
				width: 100%;
				height: 100%;
			}

		</style>
		<span>{{cameraRotation}}</span>
		<a-scene embedded id="canvas">

			<a-entity camera look-controls wasd-controls user-height="1.6">
				<!-- <a-entity raycaster="objects: #fileRepresentation" position="0 0 0.5" rotation="0 180 0"></a-entity> -->
				<!-- <a-text value="Hello. Please move around and take a look." position="0 0 -5"> </a-text> -->
			</a-entity>


			<!-- <a-obj-model id="fileRepresentation" src$="[[filePath]]"  position="-3 0 -3" on-click="clicked" opacity="1.0"
				animation__mouseenter="startEvents: mouseenter; property: opacity; to:0.5; dur:3000"
				animation__mouseleave="startEvents: mouseleave; property: opacity; to:1.0; dur:3000">
			</a-obj-model> -->

			<a-entity id="rightVRController" class="vrController" vive-controls="hand: right" on-triggerdown="onTriggerDown" controller-cursor> </a-entity>
			
			<a-entity id="leftVRController" class="vrController" vive-controls="hand: left" on-axismove="onAxisMove">

				<a-entity light="type: directional; color: #FFF; intensity: 0.6" position="-0.5 1 1"></a-entity>
				<a-entity light="type: ambient; color: #BBB"></a-entity>


				<!-- The model attribute is added on file change depending on format -->
				<a-entity id="fileRepresentation" material="color:green" scale$="[[modelScale]] [[modelScale]] [[modelScale]]" on-click="clicked" on-mouseenter="onMouseEnter" on-mouseleave="onMouseLeave">
				
					<template id="annotationList" is="dom-repeat" items="[[annotations]]">
						<a-entity position$="[[_parsePos(item.position)]]" opacity="0.0">
							<!-- <a-sphere scale="0.06 0.06 0.06" color="red"></a-sphere> -->
							<a-sphere color$="[[item.statusColor]]" scale="0.05 0.05 0.05" depth="2" animation__created="property: opacity; dur:200; to: 1.0; loop:false;"></a-sphere>
						<a-text value$="[[item.description]]"></a-text>
						</a-entity>

					</template>
				</a-entity>






			</a-entity>




		<a-sky color="gray"></a-sky>
		</a-scene>
		<span>[[filePath]]</span>

	</template>



	<script>
	'use strict' /*eslint global-strict:0*/

	// FIXME: shouldnt those global variables better reside inside the element
	// vis this.glRenderer = ...

	var controls;
	var cssObject;
	var glRenderer;
	var cssRenderer;
	var render;
	var animate;

	function jsonEqual(a,b) {
    return JSON.stringify(a) === JSON.stringify(b);
	}

	Polymer({
		is: "render-view",

		properties: {

			file: {
				type: Object,
				observer: '_fileChanged'
			},
			fileName: {
				type: String
			},
			fileEnding: {
				type: String
			},
			tool: {
				type: 'Object',
				observer: '_toolChanged'
			},
			filePath: {
				type: String,
				notify: true,
				observer: '_filePathChanged'
			},
			annotations: {
				type: Array,
				observer: "_annotationsChanged"
			},
			labels: {
				type: Map
			},
			physicalModelState: {
				type: Object,
				observer: "physicalModelStateChanged"
			},
			modelScale: {
				type: Number,
				value: 0.5
			}
			// modelScaleString: {
			// 	String,
			// 	computed: "computeVectorString(modelScale)"
			// }
		},

		listeners: {

		},

		_concat: function (...items) {
			console.log(items);
			let result = '';
			for (let item of items) {
				result += item;
			}
			console.log(result);
			return result;
			},
		_parsePos: ({x,y,z}) => {let result = `${x/1} ${y/1} ${z/1}`; console.log(result); return result },

		ready: function() {
			// doesnt work with listeners on this very element
			// so create start event listener
			console.log('renderview ready');
			this.ready = true;
			this.rendering = false;

		},
		attached: function () {
			console.log('ATTACHED');
			
			this.annotationGroup = this.$.canvas.annotations;

		},
		clicked: function (evt) {
			let pos = evt.detail.intersection.point.clone();
			this.$.fileRepresentation.object3D.worldToLocal(pos);
			this.fire('create-annotation', {
				description: 'New VR Annotation' + Math.round(Math.random() * 100),
				position: pos
			});
		},
		onMouseEnter: function (evt) {
			console.log(evt.detail);
			console.log(this.$.rightVRController);
		},
		
		onMouseLeave: function (evt) {
			console.log(evt.detail);
			console.log(this.$.rightVRController);
		},
		
		onIntersection: function (evt) {
			console.trace();
			console.log('INTERSECTION');
			console.log(evt.detail);
		},
		
		onAxisMove: function (evt) {
			this.trackPadEventCount++;

			// END of touching the pad? reset the saved axis values
			if((evt.detail.axis[0] === 0 && evt.detail.axis[1] === 0)) {
				this.axis = undefined;
				this.trackPadEventCount = 0;
				return;
			}
			
			// Discard the first few events because if inacuraccies from sensors
			if(this.trackPadEventCount < 3) return;

			
			if(this.axis === undefined) {
				this.axis = evt.detail.axis;
				return;
			}
			
			let axis = evt.detail.axis;

			let y = (axis[1] - this.axis[1]) / 10;
			this.modelScale += y;
			this.axis = axis;
		},
		
		onTriggerDown: function (evt) {

		},
		raycasterIntersection: function (evt) {
			console.log(evt);
		},

		startRendering: function() {
			if (this.rendering === false) {
				console.log('started rendering');
				this.rendering = true;
				animate();
			}
		},

		animate: function () {
			requestAnimationFrame(this.animate.bind(this));
			this.light.position.copy(this.camera.position).addScaledVector(this.camera.up, this.standardDistance);
			this.spotLight.position.copy(this.camera.position);

			controls.update();
		},

		resetGroups: function () {
			// Remove labels and annotations


			// while (this.annotationGroup.hasChildNodes()) {
  		// 	this.annotationGroup.removeChild(this.annotationGroup.lastChild);
			// }


			// this.labels = new Map();
			// if(this.labelGroup && this.annotationGlGroups) {
			//
			// 	for( var i = this.labelGroup.children.length - 1; i >= 0; i--) {
			// 		this.labelGroup.remove(this.labelGroup.children[i]);
			// 		cssScene.remove(this.labelGroup.children[i]);
			// 	}
			//
			// 	for( var i = this.annotationGlGroups.children.length - 1; i >= 0; i--) {
			// 		this.annotationGlGroups.remove(this.annotationGlGroups.children[i]);
			// 		cssScene.remove(this.annotationGlGroups.children[i]);
			// 	}
			// }

		},


		physicalModelStateChanged: function () {
			if (this.penGroupGLOrientation) {
				// TODO Use quaternion instead of euler
				// const rotation = new THREE.Quaternion().setFromEuler(new THREE.Euler(-Math.PI, 0, 0));
				const quaternion = this.physicalModelState.quat.clone();//.multiply(rotation);
				// if (this.fileRepresentation) {
				// 	this.fileRepresentation.setRotationFromQuaternion(quaternion);
				// }
				this.penGroupGLOrientation.setRotationFromQuaternion(quaternion);
				this.mouseOrPenMoved();
				// this.render();
			}
		},

		attached: function() {

			this.modus = {modelGrabbing: false};
			this.filePath = '';
			console.log('attached');
			console.log(this.$.canvas);
			console.log(this.$.fileRepresentation);
			// setInterval(() => {
			// 	this.fire('create-annotation', {
			// 		description: 'blubb' + Math.round(Math.random() * 10),
			// 		position: {x:Math.random() * 500, y:Math.random() * 500, z:Math.random() * 500},
			// 	});
			// }, 5000);


			// init annotations to empty array
			this.annotations = [];
			this.annotation3DObjects = [];
			this.resize();
			this.fire('initialized')
		},

		getPenPosition() {
			return this.penGroupGLOffset;
		},

		resize: function(event) {
			console.log(this.$.canvas);
			console.log(this.$.fileRepresentation);
			let width = this.parentNode.getBoundingClientRect().width;
			let height = this.parentNode.getBoundingClientRect().height;
			// // console.log(width, height);
			// this.style.width = width + 'px';
			// this.style.height = height + 'px';
			// // Make it visually fill the positioned parent
		  this.$.canvas.style.width ='100%';
		  this.$.canvas.style.height='100%';
		  // // ...then set the internal size to match
		  // this.$.canvas.width  = this.$.canvas.offsetWidth;
		  // this.$.canvas.height = this.$.canvas.offsetHeight;


			// // this.$.canvas.style.width = width + 'px';
			// this.$.canvas.style.height = (height - 27) + 'px';

		},
		_filePathChanged: function () {
			console.log('filePath changed!! \n\n');
		},

		_fileChanged: function () {

			this.filePath = URL.createObjectURL(this.file);

			this.$.fileRepresentation.removeAttribute('obj-model');
			this.$.fileRepresentation.removeAttribute('collada-model');
			if(this.fileEnding === 'obj') {
				this.$.fileRepresentation.setAttribute('obj-model', `obj:url(${this.filePath})`);
			} else if (this.fileEnding === 'dae') {
				this.$.fileRepresentation.setAttribute('collada-model', `url(${this.filePath})`);
			} else {
				console.error('Cannot load file with filending', this.fileEnding, '. This should have been catched at file upload.');
			}
		},

		_annotationsChanged: function() {
			console.log('_annotationsChanged');
		},

		addAnnotationObject: function (annotation) {

		},


		toggleTrack: function(e) {
			this.modus.modelGrabbing = !this.modus.modelGrabbing;
			Polymer.dom(this).classList.toggle('track');
		},

		updateMouse: function (mouseEvent) {
			this.mouse = new THREE.Vector2(
				(mouseEvent.layerX / canvas.width) * 2 - 1,
				-((mouseEvent.layerY / canvas.height) * 2 - 1)
			);
		},

		mouseOrPenMoved(event) {
			console.log('hello');
			this.previousCameraPosition = controls.object.position.clone();
			this.previousCameraRotation = controls.object.rotation.clone();
			let penActive = event === undefined;
			if (!penActive) {
				this.updateMouse(event);
			}

			let intersections = [];

			if (this.fileRepresentation) {
				if (this.tool === 'polygon' || this.tool === 'point') {
					this.raycaster.setFromCamera(this.mouse, this.camera);
				} else if(penActive) {
					const origin = this.physicalPenModel.getWorldPosition();
					const normalizedDirection = origin.clone().negate().normalize();
					this.raycaster.set(origin, normalizedDirection);
				}
				intersections = this.raycaster.intersectObject(this.fileRepresentation);

			}

			if (intersections.length !== 0) {

				if (this.modus.modelGrabbing && this.tool !== 'rotate') {
					Polymer.dom(this).classList.add('polygonCursor');
				}
				this.spotLight.target = this.pointerSphere;
				this.pointerSphere.position.set(intersections[0].point.x, intersections[0].point.y , intersections[0].point.z);

			} else {
				Polymer.dom(this).classList.remove('polygonCursor')
			}

		},

		track: function (e) {

		},

		tap: function(e) {
			console.log('tap');
			if (jsonEqual(this.previousCameraPosition, this.camera.position) === false || jsonEqual(this.previousCameraRotation, this.camera.rotation) == false) {
				console.log('moved! return!');
			}

			// Update values for: this.mouse
			this.updateMouse(e.detail.sourceEvent);

			// update the picking ray with the camera and mouse position
			this.fileRepresentation.updateMatrixWorld()
			this.raycaster.setFromCamera(this.mouse, this.camera);

			// Calculate objects intersecting the picking ray
			// only use the first/frontmost intersection  -> [0]
			const intersections = this.raycaster.intersectObject(this.fileRepresentation);
			const intersection = ( intersections.length ) > 0 ? intersections[ 0 ] : null;
			// Transform intersection point from world coordinates
			// to the local coordinate space of the mainGroupGL/mainGroupCSS (both equival. matrix)
			this.mainGroupGL.worldToLocal(intersection.point);

			switch (this.tool) {

				case 'point':

						event.preventDefault();
						// TODO: finish shape and create annotation
						this.fire('create-annotation', {
							description: '',
							polygon: [intersection.point.clone()],
							position: intersection.point.clone(),
							cameraPosition: controls.object.position.clone(),
							// cameraRotation: camera.rotation,
							cameraUp: this.camera.up
						});
						if (this.previewAnnotation !== undefined) {
							this.mainGroupGL.remove(this.previewAnnotation.arrow);
							this.mainGroupGL.remove(this.previewAnnotation.polygon);
							this.mainGroupCSS.remove(this.previewAnnotation.label);
							this.previewAnnotation = undefined;
						}
						glScene.remove(this.previewPolygon);
						this.previewPolygon = undefined;
						this.verticesPolygonTool = [];
						console.log('added polygon annotation');

					break;

				case 'polygon':
					this.verticesPolygonTool.push(intersection.point.clone());

					// create new preview polygon/shape when enough points are available
					if (this.verticesPolygonTool.length >= 3) {
							glScene.remove(this.previewPolygon);
							this.previewPolygon = this.createPolygon(this.verticesPolygonTool, 0x00ff00);
							glScene.add(this.previewPolygon);
					}

					// And show a temporary preview annotation if first tap.
					if (this.previewAnnotation === undefined) {
						this.previewAnnotation = this.addAnnotationObject({
							_id: 'previewAnnotation',
							status: 'comment',
							statusColor: 'blue',
							description: "Press Enter to edit/create. Esc to cancel.",
							position: intersection.point.clone(),
							cameraPosition: controls.object.position.clone(),
							cameraUp: this.camera.up
						});
					}

				break;
				default:
			}
		},

		createPolygon: function (vertices, color) {
			// IDEA: move to helper object?
			let polygon = new THREE.Geometry();
			polygon.vertices = vertices;

			// calculate faces of preview polygon
			for (var i = 1; i < polygon.vertices.length - 1; i++) {
				polygon.faces.push( new THREE.Face3( 0, i, i+1 ) )
			}
			return new THREE.Mesh(
				polygon,
				new THREE.MeshBasicMaterial( {
					color: color,
					side: THREE.DoubleSide
				} )
			);
		},

		createLabel: function (annotation, multFactor) {
			let div = document.createElement('div');
			let textElement = document.createElement('span');
			div.style.opacity = '0.85';
			div.style.fontSize = '30px';
			div.style.padding = "0.35em";
			div.style.background = "rgb(255, 255, 255)";
			div.style.border = annotation.statusColor + " solid 0.125em";
			div.style.transition = "opacity 0.5s";
			div.innerHTML = annotation.description;
			// div.addEventListener('mouseover', () => {
			// 	this.fire('label-over', annotation._id);
			// });
			// div.addEventListener('mouseout', () => {
			// 	this.fire('label-out', annotation._id);
			// });

			let label = new THREE.CSS3DSprite(div);
			label.userData.div = div;

			if (annotation.cameraPosition !== undefined) {
				// Convert x,y,z object into Vector3 object.
				let camPos = new THREE.Vector3(annotation.cameraPosition.x, annotation.cameraPosition.y, annotation.cameraPosition.z);
				label.position.copy(annotation.cameraPosition).multiplyScalar(0.6);
			} else {
				label.position.set(annotation.position.x, annotation.position.y, annotation.position.z);
				label.position.multiplyScalar(multFactor);
			}
			return label;
		},

		createArrow: function (point, labelpos, color) {
			var material = new THREE.LineBasicMaterial({
				color: color
			})

			var geometry = new THREE.Geometry()
			geometry.vertices.push(
				point,
				labelpos
			)

			return new THREE.Line( geometry, material )
		},

		focusAnnotation: function (annotation) {
			if (annotation.cameraPosition !== undefined) {
				// The resetFrom function was added by me (modified .reset()) to allow
				// reset from a saved position (eg. stored in the DB)
				controls.resetFrom(annotation.cameraPosition, annotation.cameraUp);
			} else {
				return;
			}
		}
	})
	</script>


</dom-module>
