<!DOCTYPE html>

<link rel="import" href="a-annotation.html">


<dom-module id="render-view">

	<template>
		<style is="custom-style">


			:host {
				margin: 0;
				width: 100%;
				height: 100%;
			}

			/*#canvas {
				width: 100%;
				height: 100%;
			}*/
			a-scene {
				width: 100%;
				height: 100%;
			}

		</style>
		<span>{{cameraRotation}}</span>
		<a-scene embedded id="canvas">

			<a-entity camera look-controls wasd-controls user-height="1.6">
				<!-- <a-entity raycaster="objects: #fileRepresentation" position="0 0 0.5" rotation="0 180 0"></a-entity> -->
				<!-- <a-text value="Hello. Please move around and take a look." position="0 0 -5"> </a-text> -->

			</a-entity>


			<!-- <a-obj-model id="fileRepresentation" src$="[[filePath]]"  position="-3 0 -3" on-click="clicked" opacity="1.0"
				animation__mouseenter="startEvents: mouseenter; property: opacity; to:0.5; dur:3000"
				animation__mouseleave="startEvents: mouseleave; property: opacity; to:1.0; dur:3000">
			</a-obj-model> -->

			<a-entity light="type: ambient; color: #BBB"></a-entity>

			<a-entity id="rightVRController" class="vrController" laser-controls="hand: right" raycaster="objects: #fileRepresentation;" on-triggerdown="onTriggerDown" on-triggerup="onTriggerUp" on-raycaster-intersection="onIntersection">

				<a-entity light="type: directional; color: #FFF; intensity: 0.6" position="-0.5 1 1"></a-entity>

				<a-text value$="[[STTResult.transcript]]" position="0 -0.1 0.0" scale="0.2 0.2 0.2"> </a-text>

			</a-entity>

			<a-entity id="leftVRController" class="vrController" vive-controls="hand: left" on-axismove="onAxisMove">





				<!-- The model attribute is added on file change depending on format -->
				<a-entity id="fileRepresentation" material="opacity:0.75; roughness: 0.2; metalness: 0.8" scale$="[[modelScale]] [[modelScale]] [[modelScale]]" on-click="clicked" on-mouseenter="onMouseEnter" on-mouseleave="onMouseLeave">

					<a-sphere color="red" scale="0.05 0.05 0.05" position$="[[_parsePos(intersectionPoint)]]"></a-sphere>

					<template id="annotationList" is="dom-repeat" items="[[annotations]]">
						<a-entity position$="[[_parsePos(item.localPosition)]]" opacity="1.0">
							<!-- <a-sphere scale="0.06 0.06 0.06" color="red"></a-sphere> -->
							<a-sphere color$="[[item.statusColor]]" scale="0.05 0.05 0.05" depth="2" animation__created="property: opacity; dur:200; to: 1.0; loop:false;"></a-sphere>

						<a-entity rotation="0 -90 0">

							<a-text scale="1.5 1.5 1.5" look-at$="[[_parsePos(item.worldCameraPosition)]]" alpha-test="0.9" side="double" value$="[[item.description]]"></a-text>

						</a-entity>

						</a-entity>

					</template>
				</a-entity>

			</a-entity>




		<a-sky color="gray"></a-sky>
		</a-scene>
		<span>[[filePath]]</span>

	</template>



	<script>
	'use strict' /*eslint global-strict:0*/

	// FIXME: shouldnt those global variables better reside inside the element
	// vis this.glRenderer = ...

	var controls;
	var cssObject;
	var glRenderer;
	var cssRenderer;
	var render;
	var animate;


	Polymer({
		is: "render-view",

		properties: {

			file: {
				type: Object,
				observer: '_fileChanged'
			},
			fileName: {
				type: String
			},
			fileEnding: {
				type: String
			},
			tool: {
				type: 'Object',
				observer: '_toolChanged'
			},
			filePath: {
				type: String,
				notify: true,
				observer: '_filePathChanged',
				value: ''
			},
			annotations: {
				type: Array,
				observer: "_annotationsChanged",
				value: []
			},
			labels: {
				type: Map
			},
			physicalModelState: {
				type: Object,
				observer: "physicalModelStateChanged"
			},
			modelScale: {
				type: Number,
				value: 0.5
			},
			STTResult: {
				type: Object,
				value: {transcript: ''}
			}
			// modelScaleString: {
			// 	String,
			// 	computed: "computeVectorString(modelScale)"
			// }
		},

		listeners: {

		},

		_concat: function (...items) {
			console.log(items);
			let result = '';
			for (let item of items) {
				result += item;
			}
			console.log(result);
			return result;
			},
		_parsePos: ({x,y,z}) => {return `${x/1} ${y/1} ${z/1}`;},

		ready: function() {
			this.ready = true;
			this.rendering = false;
		},
		attached: function () {
			console.log('ATTACHED');
		},
		clicked: function (evt) {
			console.log(this.STTResult);

			console.log(evt.detail);
			let intersection = evt.detail.intersection;
			let pos = intersection.point.clone();
			this.$.fileRepresentation.object3D.worldToLocal(pos);
			let {x, y, z} = this.$.rightVRController.getAttribute('position');
			let localCameraPos = new THREE.Vector3(x, y, z);
			let worldCameraPos = localCameraPos.clone();

			this.$.fileRepresentation.object3D.worldToLocal(worldCameraPos);
			console.log(cameraPos);
			console.warn('\n\nTODO: FILL IN ACTUAL cameraUp value!\n\n');
			console.trace();
			this.fire('create-annotation', {
				description: this.STTResult.transcript,
				localCameraPosition: cameraPos,
				worldCameraPosition: worldCameraPos,
				cameraUp: new THREE.Vector3(0,1,0),
				polygon: [pos],
				localPosition: pos,
				/* fill out world position */
			});

		},
		onMouseEnter: function (evt) {
		},

		onMouseLeave: function (evt) {
		},

		onIntersection: function (evt) {
			let pos = evt.detail.intersections[0].point.clone();
			this.$.fileRepresentation.object3D.worldToLocal(pos);
			this.intersectionPoint = pos;
		},

		onAxisMove: function (evt) {
			this.trackPadEventCount++;

			// END of touching the pad? reset the saved axis values
			if((evt.detail.axis[0] === 0 && evt.detail.axis[1] === 0)) {
				this.axis = undefined;
				this.trackPadEventCount = 0;
				return;
			}

			// Discard the first few events because if inacuraccies from sensors
			if(this.trackPadEventCount < 3) return;


			if(this.axis === undefined) {
				this.axis = evt.detail.axis;
				return;
			}

			let axis = evt.detail.axis;
			let y = (axis[1] - this.axis[1]) / 10;
			this.modelScale += y;
			this.axis = axis;
		},

		onTriggerDown: function (evt) {
			this.triggerDown = true;
			this.STTResult = {transcript: ''};
		},
		onTriggerUp: function (evt) {
			this.triggerDown = false;
		},


		physicalModelStateChanged: function () {
			// Not implemented in A-Frame branch cause position/rotation change is handled via one
			// of the vive controllers
		},

		attached: function() {

			this.modus = {modelGrabbing: false};

			fetch('/api/speech-to-text/token')
			.then(response => {return response.text()})
			.then(token => {
				this.STTStream = WatsonSpeech.SpeechToText.recognizeMicrophone({
					token: token,
					interim_results: true,
					realtime: true,
					smart_formatting: true,
					objectMode: true // default false
				});

				// this.STTStream.setEncoding('utf8'); // get text instead of Buffers for on data events
				this.STTStream.on('data', data => {
					// console.log(data);
					if(this.triggerDown) this.STTResult = data.results[0].alternatives[0];

					// console.log(this.STTResult.results[0]);
				});
				this.STTStream.on('error', err => {
					console.log('ERROR\n\n\n');
					console.log(err);
				});
			});

			this.resize();
			this.fire('initialized');
		},


		resize: function(event) {
			let width = this.parentNode.getBoundingClientRect().width;
			let height = this.parentNode.getBoundingClientRect().height;
			// // console.log(width, height);
			// this.style.width = width + 'px';
			// this.style.height = height + 'px';
			// // Make it visually fill the positioned parent
		  this.$.canvas.style.width ='100%';
		  this.$.canvas.style.height='100%';
		  // // ...then set the internal size to match
		  // this.$.canvas.width  = this.$.canvas.offsetWidth;
		  // this.$.canvas.height = this.$.canvas.offsetHeight;


			// // this.$.canvas.style.width = width + 'px';
			// this.$.canvas.style.height = (height - 27) + 'px';

		},
		_filePathChanged: function () {
			console.log('filePath changed!! \n\n');
		},

		_fileChanged: function () {

			this.filePath = URL.createObjectURL(this.file);

			this.$.fileRepresentation.removeAttribute('obj-model');
			this.$.fileRepresentation.removeAttribute('collada-model');
			if(this.fileEnding === 'obj') {
				this.$.fileRepresentation.setAttribute('obj-model', `obj:url(${this.filePath})`);
			} else if (this.fileEnding === 'dae') {
				this.$.fileRepresentation.setAttribute('collada-model', `url(${this.filePath})`);
			} else {
				console.error('Cannot load file with filending', this.fileEnding, '. This should have been catched at file upload.');
			}
		},

		_annotationsChanged: function() {
			// console.log('_annotationsChanged');
		},

		toggleTrack: function(e) {
			//this.modus.modelGrabbing = !this.modus.modelGrabbing;
			// Polymer.dom(this).classList.toggle('track');
		},


		track: function (e) {

		},

		tap: function(e) {

		},

		createPolygon: function (vertices, color) {
			// // IDEA: move to helper object?
			// let polygon = new THREE.Geometry();
			// polygon.vertices = vertices;
			//
			// // calculate faces of preview polygon
			// for (var i = 1; i < polygon.vertices.length - 1; i++) {
			// 	polygon.faces.push( new THREE.Face3( 0, i, i+1 ) )
			// }
			// return new THREE.Mesh(
			// 	polygon,
			// 	new THREE.MeshBasicMaterial( {
			// 		color: color,
			// 		side: THREE.DoubleSide
			// 	} )
			// );
		}

	})
	</script>


</dom-module>
