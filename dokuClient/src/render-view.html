
<dom-module id="render-view">

	<template>
		<style is="custom-style">


			:host {
				margin: 0;
				width: 100%;
				height: 100%;
			}

			#canvas {
				width: 100%;
				height: 100%;

			}

		</style>

		<a-scene embedded debug id="canvas">
		<!-- <a-box color="#6173F4" opacity="0.8" depth="2"></a-box> -->
		<a-obj-model id="fileRepresentation" src$="[[filePath]]"></a-obj-model>

		<template is="dom-repeat" items="[[annotations]]">
			<a-entity color$="[[item.statusColor]]" text$="value:[[item._id]]"></a-entity>
		</template>

		<!-- <a-sphere radius="2" position="1 1 -10"></a-sphere> -->
		<a-sky color="gray"></a-sky>
		</a-scene>
		<span>[[filePath]]</span>

	</template>



	<script>
	'use strict' /*eslint global-strict:0*/

	// FIXME: shouldnt those global variables better reside inside the element
	// vis this.glRenderer = ...

	var controls;
	var cssObject;
	var glRenderer;
	var cssRenderer;
	var render;
	var animate;

	function jsonEqual(a,b) {
    return JSON.stringify(a) === JSON.stringify(b);
	}

	Polymer({
		is: "render-view",

		properties: {

			file: {
				type: Object,
				observer: '_fileChanged'
			},
			tool: {
				type: 'Object',
				observer: '_toolChanged'
			},
			filePath: {
				type: String,
				notify: true,
				observer: '_filePathChanged'
			},
			annotations: {
				type: Array,
				observer: "_annotationsChanged"
			},
			labels: {
				type: Map
			},
			physicalModelState: {
				type: Object,
				observer: "physicalModelStateChanged"
			}
		},

		listeners: {

		},

		ready: function() {
			// doesnt work with listeners on this very element
			// so create start event listener
			console.log('renderview ready');
			this.ready = true;
			this.rendering = false;

		},

		startRendering: function() {
			if (this.rendering === false) {
				console.log('started rendering');
				this.rendering = true;
				animate();
			}
		},

		animate: function () {
			requestAnimationFrame(this.animate.bind(this));
			this.light.position.copy(this.camera.position).addScaledVector(this.camera.up, this.standardDistance);
			this.spotLight.position.copy(this.camera.position);

			controls.update();
		},

		resetGroups: function () {
			// Remove labels and annotations
			this.labels = new Map();
			if(this.labelGroup && this.annotationGlGroups) {

				for( var i = this.labelGroup.children.length - 1; i >= 0; i--) {
					this.labelGroup.remove(this.labelGroup.children[i]);
					cssScene.remove(this.labelGroup.children[i]);
				}

				for( var i = this.annotationGlGroups.children.length - 1; i >= 0; i--) {
					this.annotationGlGroups.remove(this.annotationGlGroups.children[i]);
					cssScene.remove(this.annotationGlGroups.children[i]);
				}
			}

		},


		physicalModelStateChanged: function () {
			if (this.penGroupGLOrientation) {
				// TODO Use quaternion instead of euler
				// const rotation = new THREE.Quaternion().setFromEuler(new THREE.Euler(-Math.PI, 0, 0));
				const quaternion = this.physicalModelState.quat.clone();//.multiply(rotation);
				// if (this.fileRepresentation) {
				// 	this.fileRepresentation.setRotationFromQuaternion(quaternion);
				// }
				this.penGroupGLOrientation.setRotationFromQuaternion(quaternion);
				this.mouseOrPenMoved();
				// this.render();
			}
		},

		attached: function() {

			this.modus = {modelGrabbing: false};
			this.filePath = '';
			console.log('attached');
			console.log(this.$.canvas);
			console.log(this.$.fileRepresentation);



			// init annotations to empty array
			this.annotations = [];
			this.annotation3DObjects = [];
			this.resize();
			this.fire('initialized')
		},

		getPenPosition() {
			return this.penGroupGLOffset;
		},

		resize: function(event) {
			console.log(this.$.canvas);
			console.log(this.$.fileRepresentation);
			let width = this.parentNode.getBoundingClientRect().width;
			let height = this.parentNode.getBoundingClientRect().height;
			// // console.log(width, height);
			// this.style.width = width + 'px';
			// this.style.height = height + 'px';
			// // Make it visually fill the positioned parent
		  this.$.canvas.style.width ='100%';
		  this.$.canvas.style.height='100%';
		  // // ...then set the internal size to match
		  // this.$.canvas.width  = this.$.canvas.offsetWidth;
		  // this.$.canvas.height = this.$.canvas.offsetHeight;


			// // this.$.canvas.style.width = width + 'px';
			// this.$.canvas.style.height = (height - 27) + 'px';

		},
		_filePathChanged: function () {
			console.log('filePath changed!! \n\n');
		},

		_fileChanged: function () {

			this.filePath = 'http://localhost:8000/images/box.obj'; //URL.createObjectURL(this.file);


			// console.log('fileChanged')
			// console.log(this.file)
			//
			// this.resetGroups();
			// this.annotations = [];
			//
			// // load the file and use it for display
			// var loader = new THREE.STLLoader()
			// var filepath = URL.createObjectURL(this.file)
			// loader.load(filepath,
			// 	geometry  => {
			// 		const meshFromFile = new THREE.Mesh(geometry, this.meshMaterial);
			// 		meshFromFile.castShadow = true;
			// 		meshFromFile.receiveShadow = true;
			// 		this.boundingBox = new THREE.Box3().setFromObject(meshFromFile);
			// 		this.maxLength = Math.max(this.boundingBox.max.x, this.boundingBox.max.y, this.boundingBox.max.z);
			// 		// TODO: Save scale factor in DB.
			// 		meshFromFile.scale.set(this.standardDistance/this.maxLength, this.standardDistance/this.maxLength, this.standardDistance/this.maxLength);
			// 		var height = this.boundingBox.size().y;
			// 		var pos = glScene.position;
			//
			//
			// 		// swap existing mesh with new mesh
			// 		if (this.fileRepresentation !== undefined)
			// 			this.mainGroupGL.remove(this.fileRepresentation);
			//
			// 		this.fileRepresentation = meshFromFile;
			// 		this.mainGroupCSS = new THREE.Object3D();
			// 		this.mainGroupGL = new THREE.Object3D();
			//
			//
			// 		// create group for text annotations in 3D
			// 		if (this.labelGroup === undefined)
			// 			this.labelGroup = new THREE.Object3D();
			// 		if (this.annotationGlGroups === undefined)
			// 			this.annotationGlGroups = new THREE.Object3D();
			//
			// 		this.mainGroupCSS.add(this.labelGroup);
			// 		this.mainGroupGL.add(this.annotationGlGroups);
			// 		this.mainGroupGL.add(this.fileRepresentation);
			// 		glScene.add(this.mainGroupGL);
			// 		glScene.add(this.penGroupGLOffset);
			// 		cssScene.add(this.mainGroupCSS);
			//
			// 		this.animate();
			// 	}
			// );
		},

		_annotationsChanged: function() {
			console.log('_annotationsChanged');
			// debug output of annotations
			// first remove all previous annotations
			// FIXME: only update modified ones, instead of removing and completely re-creating
			// this.resetGroups();
			//
			// for (let annotation of this.annotations) {
			// 	this.addAnnotationObject(annotation);
			// }

		},

		addAnnotationObject: function (annotation) {
			let annotation3DObject = {};
			let annotationGlGroup = new THREE.Object3D();
			let multFactor = 2;
			let label = this.createLabel(annotation, multFactor);

			this.labels.set(annotation._id, label);
			this.labelGroup.add(label);
			annotation3DObject.label = label;

			// TODO: add arrow, label to a group/structure to be selectable
			let arrow = this.createArrow(annotation.position, label.position, annotation.statusColor);
			annotationGlGroup.add(arrow);


			let sphere = new THREE.Mesh(
				new THREE.SphereGeometry(this.standardDistance / 100, 6, 6),
				new THREE.MeshLambertMaterial({ color: 0xff0000})
			);
			sphere.position.copy(annotation.position);
			annotationGlGroup.add(sphere);

			annotation3DObject.arrow = arrow;

			// if annotation has polygon info, create it and add it to the scene
			if (annotation.polygon !== undefined) {
				let polygon = this.createPolygon(annotation.polygon, annotation.creatorProfile.color);
				annotationGlGroup.add(polygon)
				annotation3DObject.polygon = polygon
			}
			this.annotationGlGroups.add(annotationGlGroup);
			annotation3DObject.glGroup = annotationGlGroup;
			this.annotation3DObjects.push(annotation3DObject);
			return annotation3DObject;
		},

		updateAnnotationVisibility: function () {
			// TODO: there is a PR on threejs for raycasting in css renderer, use it once ready
			// triggered on controls update
			let raycaster = new THREE.Raycaster()

			if (this.labelGroup.children === undefined) return

			for(let label of this.labelGroup.children) {
				let normalizedDirection = (label.position.clone().sub(this.camera.position)).normalize()
				raycaster.set(this.camera.position.clone(), normalizedDirection)
				raycaster.far = this.camera.position.distanceTo(label.position)
				let intersections = raycaster.intersectObject(this.fileRepresentation)
				if (intersections.length !== 0) {
					label.element.style.opacity = 0.0
				} else {
					label.element.style.opacity = 0.8
				}
			}

		},

		toggleTrack: function(e) {
			this.modus.modelGrabbing = !this.modus.modelGrabbing;
			Polymer.dom(this).classList.toggle('track');
		},

		updateMouse: function (mouseEvent) {
			// let canvas = this.$$('canvas');
			// this.mouse = new THREE.Vector2(
			// 	(mouseEvent.layerX / canvas.width) * 2 - 1,
			// 	-((mouseEvent.layerY / canvas.height) * 2 - 1)
			// );
		},

		mouseOrPenMoved(event) {
			console.log('hello');
			this.previousCameraPosition = controls.object.position.clone();
			this.previousCameraRotation = controls.object.rotation.clone();
			let penActive = event === undefined;
			if (!penActive) {
				this.updateMouse(event);
			}

			let intersections = [];

			if (this.fileRepresentation) {
				if (this.tool === 'polygon' || this.tool === 'point') {
					this.raycaster.setFromCamera(this.mouse, this.camera);
				} else if(penActive) {
					const origin = this.physicalPenModel.getWorldPosition();
					const normalizedDirection = origin.clone().negate().normalize();
					this.raycaster.set(origin, normalizedDirection);
				}
				intersections = this.raycaster.intersectObject(this.fileRepresentation);

			}

			if (intersections.length !== 0) {

				if (this.modus.modelGrabbing && this.tool !== 'rotate') {
					Polymer.dom(this).classList.add('polygonCursor');
				}
				this.spotLight.target = this.pointerSphere;
				this.pointerSphere.position.set(intersections[0].point.x, intersections[0].point.y , intersections[0].point.z);

			} else {
				Polymer.dom(this).classList.remove('polygonCursor')
			}

		},

		keydown: function (e) {
			if (e.defaultPrevented) {
				return; // Should do nothing if the key event was already consumed.
			}

			switch (e.which) {
				case 13: /*Enter*/
					console.log('pressed enter');
					if (this.tool === 'polygon' && this.verticesPolygonTool.length !== 0){
						event.preventDefault();
						// TODO: finish shape and create annotation
						this.fire('create-annotation', {
							description: '',
							polygon: this.verticesPolygonTool,
							position: this.verticesPolygonTool[0],
							cameraPosition: controls.object.position.clone(),
							// cameraRotation: camera.rotation,
							cameraUp: this.camera.up
						});
						if (this.previewAnnotation !== undefined) {
							this.mainGroupGL.remove(this.previewAnnotation.arrow);
							this.mainGroupGL.remove(this.previewAnnotation.polygon);
							this.mainGroupCSS.remove(this.previewAnnotation.label);
							this.previewAnnotation = undefined;
						}
						glScene.remove(this.previewPolygon);
						this.previewPolygon = undefined;
						this.verticesPolygonTool = [];
						console.log('added polygon annotation');
					}
					break;
					case 27 /* Escape */:
						console.log(this.previewAnnotation);
						if (this.previewPolygon !== undefined){
							glScene.remove(this.previewPolygon);
							this.previewPolygon = undefined;
						}

						if(this.previewAnnotation !== undefined) {
							// Remove preview annotation
							this.annotationGlGroups.remove(this.previewAnnotation.glGroup);
							this.labelGroup.remove(this.previewAnnotation.label);
							this.previewAnnotation = undefined;
						}

						this.verticesPolygonTool = [];
					break;
				default:

					break;
			}
		},
		track: function (e) {

		},
		tap: function(e) {
			console.log('tap');
			if (jsonEqual(this.previousCameraPosition, this.camera.position) === false || jsonEqual(this.previousCameraRotation, this.camera.rotation) == false) {
				console.log('moved! return!');
			}

			// Update values for: this.mouse
			this.updateMouse(e.detail.sourceEvent);

			// update the picking ray with the camera and mouse position
			this.fileRepresentation.updateMatrixWorld()
			this.raycaster.setFromCamera(this.mouse, this.camera);

			// Calculate objects intersecting the picking ray
			// only use the first/frontmost intersection  -> [0]
			const intersections = this.raycaster.intersectObject(this.fileRepresentation);
			const intersection = ( intersections.length ) > 0 ? intersections[ 0 ] : null;
			// Transform intersection point from world coordinates
			// to the local coordinate space of the mainGroupGL/mainGroupCSS (both equival. matrix)
			this.mainGroupGL.worldToLocal(intersection.point);

			switch (this.tool) {

				case 'point':

						event.preventDefault();
						// TODO: finish shape and create annotation
						this.fire('create-annotation', {
							description: '',
							polygon: [intersection.point.clone()],
							position: intersection.point.clone(),
							cameraPosition: controls.object.position.clone(),
							// cameraRotation: camera.rotation,
							cameraUp: this.camera.up
						});
						if (this.previewAnnotation !== undefined) {
							this.mainGroupGL.remove(this.previewAnnotation.arrow);
							this.mainGroupGL.remove(this.previewAnnotation.polygon);
							this.mainGroupCSS.remove(this.previewAnnotation.label);
							this.previewAnnotation = undefined;
						}
						glScene.remove(this.previewPolygon);
						this.previewPolygon = undefined;
						this.verticesPolygonTool = [];
						console.log('added polygon annotation');

					break;

				case 'polygon':
					this.verticesPolygonTool.push(intersection.point.clone());

					// create new preview polygon/shape when enough points are available
					if (this.verticesPolygonTool.length >= 3) {
							glScene.remove(this.previewPolygon);
							this.previewPolygon = this.createPolygon(this.verticesPolygonTool, 0x00ff00);
							glScene.add(this.previewPolygon);
					}

					// And show a temporary preview annotation if first tap.
					if (this.previewAnnotation === undefined) {
						this.previewAnnotation = this.addAnnotationObject({
							_id: 'previewAnnotation',
							status: 'comment',
							statusColor: 'blue',
							description: "Press Enter to edit/create. Esc to cancel.",
							position: intersection.point.clone(),
							cameraPosition: controls.object.position.clone(),
							cameraUp: this.camera.up
						});
					}

				break;
				default:
			}
		},

		createPolygon: function (vertices, color) {
			// IDEA: move to helper object?
			let polygon = new THREE.Geometry();
			polygon.vertices = vertices;

			// calculate faces of preview polygon
			for (var i = 1; i < polygon.vertices.length - 1; i++) {
				polygon.faces.push( new THREE.Face3( 0, i, i+1 ) )
			}
			return new THREE.Mesh(
				polygon,
				new THREE.MeshBasicMaterial( {
					color: color,
					side: THREE.DoubleSide
				} )
			);
		},

		createLabel: function (annotation, multFactor) {
			let div = document.createElement('div');
			let textElement = document.createElement('span');
			div.style.opacity = '0.85';
			div.style.fontSize = '30px';
			div.style.padding = "0.35em";
			div.style.background = "rgb(255, 255, 255)";
			div.style.border = annotation.statusColor + " solid 0.125em";
			div.style.transition = "opacity 0.5s";
			div.innerHTML = annotation.description;
			// div.addEventListener('mouseover', () => {
			// 	this.fire('label-over', annotation._id);
			// });
			// div.addEventListener('mouseout', () => {
			// 	this.fire('label-out', annotation._id);
			// });

			let label = new THREE.CSS3DSprite(div);
			label.userData.div = div;

			if (annotation.cameraPosition !== undefined) {
				// Convert x,y,z object into Vector3 object.
				let camPos = new THREE.Vector3(annotation.cameraPosition.x, annotation.cameraPosition.y, annotation.cameraPosition.z);
				label.position.copy(annotation.cameraPosition).multiplyScalar(0.6);
			} else {
				label.position.set(annotation.position.x, annotation.position.y, annotation.position.z);
				label.position.multiplyScalar(multFactor);
			}
			return label;
		},

		createArrow: function (point, labelpos, color) {
			var material = new THREE.LineBasicMaterial({
				color: color
			})

			var geometry = new THREE.Geometry()
			geometry.vertices.push(
				point,
				labelpos
			)

			return new THREE.Line( geometry, material )
		},

		focusAnnotation: function (annotation) {
			if (annotation.cameraPosition !== undefined) {
				// The resetFrom function was added by me (modified .reset()) to allow
				// reset from a saved position (eg. stored in the DB)
				controls.resetFrom(annotation.cameraPosition, annotation.cameraUp);
			} else {
				return;
			}
		}
	})
	</script>


</dom-module>
