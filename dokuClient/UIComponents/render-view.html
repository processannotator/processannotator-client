<link rel="import" href="../bower_components/polymer/polymer.html">
<script src="../libs/three/three.min.js"></script>
<script src="../libs/three/controls/TrackballControls.js"></script>
<script src="../libs/three/renderers/CSS3DRenderer.js"></script>
<script src="../libs/three/loaders/STLLoader.js"></script>

<dom-module id="render-view">

	<template>
	<style is="custom-style">
	:host {
		margin: 0;
		cursor: -webkit-grab;
		min-height: 100%;
		min-width: 100%;
	}

	:host.track {
		cursor: -webkit-grabbing;
	}



	:host:hover {}

	canvas {
		width: 100%;
		height: 100%;
	}

	:host.polygonCursor {
		cursor: crosshair;

	}
		</style>

	</template>

	<script>


	// FIXME: shouldnt those global variables better reside inside the element
	// vis this.glRenderer = ...
	var glScene = new THREE.Scene()
	var cssScene = new THREE.Scene()
	var camera
	var controls
	var cssObject
	var glRenderer
	var cssRenderer
	var render
	var animate

	Polymer({
		is: "render-view",
		properties: {
			fileRepresentation: Object,
			file: {
				type: Object,
				observer: '_fileChanged'
			},
			annotations: {
				type: Array,
				observer: "_annotationsChanged"
			}
		},
		listeners: {
			'up': 'toggleTrack',
			'down': 'toggleTrack',
			'mousemove': 'mouseMoved',
			'tap': 'tap'
		},

		ready: function() {
			// doesnt work with listeners on this very element
			// so create start event listener
			console.log('renderview ready')
			this.ready = true
			this.rendering = false
			document.addEventListener('keydown', this.keydown.bind(this))
		},
		startRendering: function() {
			if(this.rendering === false) {
				console.log('started rendering');
				this.rendering = true
				animate()
				controls.update()
			}
		},
		animate: function () {
			requestAnimationFrame(this.animate.bind(this))
			controls.update()
		},
		render: function() {
			glRenderer.render(glScene, camera)
			cssRenderer.render(cssScene, camera)
		},

		attached: function() {

			this.modus = {tool: '', modelGrabbing: false}
			// the render-view is interested in the state of the tool-box selector
			// lets add the event listener then
			var toolBox = Polymer.dom(this.parent).querySelector('#tool-box')
			if (toolBox) {
				toolBox.addEventListener('iron-select', this.toolChanged.bind(this))
			} else {
				console.error('tool-box no found inside renderViews attached function. Maybe use different way to use toolbox?');
			}


			let width = this.parentNode.getBoundingClientRect().width
			let height = this.parentNode.getBoundingClientRect().height

			camera = new THREE.PerspectiveCamera(45, width / height, 0.1, width * 50)
			camera.position.set(800, 800, 800)

			glRenderer = new THREE.WebGLRenderer({
				antialias: true,
				alpha: true
			})
			glRenderer.setClearColor(0x00ff00, 0.0)
			glRenderer.setSize(width, height)

			// let both renderers/canvases overlap
			glRenderer.domElement.style.position = 'absolute';
			glRenderer.domElement.style.top = 0;

			// cssRenderer is used for font rendering
			cssRenderer = new THREE.CSS3DRenderer()
			cssRenderer.setSize(width, height)

			glRenderer.domElement.id = 'glRenderer'
			cssRenderer.domElement.id = 'cssRenderer'
			Polymer.dom(this.root).appendChild(glRenderer.domElement)
			Polymer.dom(this.root).appendChild(cssRenderer.domElement)

			// create group for text annotations in 3D
			this.labelGroup = new THREE.Object3D()
			this.annotationGlGroups = new THREE.Object3D()
			cssScene.add(this.labelGroup)
			glScene.add(this.annotationGlGroups)

			// setup 3d-controls (rotating the camera with cursor)
			controls = new THREE.TrackballControls(camera, this)
			controls.rotateSpeed = 1.0
			controls.zoomSpeed = 1.2
			controls.panSpeed = 0.8
			controls.noZoom = false
			controls.noPan = false
			controls.staticMoving = true;
			controls.dynamicDampingFactor = 0.3
			controls.keys = [65, 83, 68]

			// add cursor pointer to 3D scene
			var sphereGeometry = new THREE.SphereGeometry( 15, 16, 16 )
			var sphereMaterial = new THREE.MeshBasicMaterial( {color: 0xff0000} )
			this.pointerSphere = new THREE.Mesh( sphereGeometry, sphereMaterial )
			glScene.add(this.pointerSphere)

			// create Raycaster used for polygon editing tool
			this.raycaster = new THREE.Raycaster()

			controls.addEventListener('change', this.render.bind(this))
			controls.addEventListener('change', this.updateAnnotationVisibility.bind(this))
			controls.handleResize()

			// init annotations to empty array
			this.annotations = []
			this.annotation3DObjects = []

			this.fire('initialized')
		},

		resize: function(event) {
			let width = this.parentNode.getBoundingClientRect().width
			let height = this.parentNode.getBoundingClientRect().height
			glRenderer.setSize(width, height)
			cssRenderer.setSize(width, height)
			camera.aspect = width / height
			camera.updateProjectionMatrix()
			controls.handleResize()
			this.render()
		},

		_fileChanged: function () {
			console.log('fileChanged')
			console.log(this.file)

			// load the file and use it for display
			var loader = new THREE.STLLoader()
			var filepath = URL.createObjectURL(this.file)
			loader.load(filepath,
				geometry  => {
					var material = new THREE.MeshNormalMaterial({
						side: THREE.DoubleSide
					})
					var meshFromFile = new THREE.Mesh(geometry, material)
					meshFromFile.scale.set(0.025, 0.025, 0.025)

					// swap existing mesh with new mesh
					glScene.add(meshFromFile)
					glScene.remove(this.fileRepresentation)
					this.fileRepresentation = meshFromFile
					this.render()
					this.animate()
				}
			);
		},

		_annotationsChanged: function() {
			console.log('_annotationsChanged')
			console.log(this.annotations)
			// debug output of annotations
			// first remove all previous annotations
			// FIXME: only update modified ones, instead of removing and completely re-creating
			if(this.labelGroup !== undefined){
				for (let child of this.labelGroup.children) {
					this.labelGroup.remove(child)
				}
			}

			for (let annotation of this.annotations) {
				let annotation3DObject = {}
				let annotationGlGroup = new THREE.Object3D()
				let multFactor = 2
				console.log(annotation)
				let label = this.createLabel(annotation.description, annotation.position, multFactor, annotation.creatorProfile.color)
				this.labelGroup.add(label)
				annotation3DObject.label = label

				// TODO: add arrow, label to a group/structure to be selectable
				let arrow = this.createArrow(annotation.position, multFactor, annotation.creatorProfile.color)
				annotationGlGroup.add(arrow)
				annotation3DObject.arrow = arrow

				// if annotation has polygon info, create it and add it to the scene
				if(annotation.polygon !== undefined) {
					let polygon = this.createPolygon(annotation.polygon, annotation.creatorProfile.color)
					annotationGlGroup.add(polygon)
					annotation3DObject.polygon = polygon
				}
				this.annotationGlGroups.add(annotationGlGroup)
				this.annotation3DObjects.push(annotation3DObject)
			}
			this.render()
		},

		updateAnnotationVisibility: function () {
			// TODO: there is a PR on threejs for raycasting in css renderer, use it once ready
			// triggered on controls update
			let raycaster = new THREE.Raycaster()

			if(this.labelGroup.children === undefined) return

			for(let label of this.labelGroup.children) {
				let normalizedDirection = (label.position.clone().sub(camera.position)).normalize()
				raycaster.set(camera.position.clone(), normalizedDirection)
				raycaster.far = camera.position.distanceTo(label.position)
				let intersections = raycaster.intersectObject(this.fileRepresentation)
				if(intersections.length !== 0) {
					label.element.style.opacity = 0.0
				} else {
					label.element.style.opacity = 0.8
				}
			}
			this.render()

		},

		toggleTrack: function(e) {
			this.modus.modelGrabbing = !this.modus.modelGrabbing
			Polymer.dom(this).classList.toggle('track')
		},

		updateMouse: function (mouseEvent) {
			let canvas = this.$$('canvas')
			this.mouse = new THREE.Vector2(
				(mouseEvent.layerX / canvas.width) * 2 - 1,
				-((mouseEvent.layerY / canvas.height) * 2 - 1)
			)
		},

		mouseMoved: function (e) {
			if(this.modus.tool === 'polygon') {
				this.updateMouse(e)
				this.raycaster.setFromCamera(this.mouse, camera)
				let intersections = this.raycaster.intersectObject(this.fileRepresentation)

				if(intersections.length !== 0){
					if(this.modus.modelGrabbing === false)
						Polymer.dom(this).classList.add('polygonCursor')
					this.pointerSphere.position.set(intersections[0].point.x, intersections[0].point.y , intersections[0].point.z)
				} else {
					Polymer.dom(this).classList.remove('polygonCursor')
				}
			}
		},

		keydown: function (e) {
			if (event.defaultPrevented) {
				return; // Should do nothing if the key event was already consumed.
			}

			switch (e.keyIdentifier) {
				case 'Enter':
					if(this.modus.tool === 'polygon' && this.verticesPolygonTool.length !== 0){
						// TODO: finish shape and create annotation
						console.log('pressed enter in polygon mode')
						addAnnotation({
							description: 'new polygon...',
							polygon: this.verticesPolygonTool,
							position: this.verticesPolygonTool[0]
						}).then(() => {
							glScene.remove(this.previewPolygon)
							this.previewPolygon = undefined
							this.verticesPolygonTool = []
							console.log('added polygon annotation')
						})
					}
					break;
				default:

			}

		},
		tap: function(e) {
			console.log(this.modus.tool)
			switch (this.modus.tool) {
				case 'polygon':

					this.updateMouse(e.detail.sourceEvent)

					// update the picking ray with the camera and mouse position
					this.raycaster.setFromCamera(this.mouse, camera);

					// calculate objects intersecting the picking ray
					// only use the frontmost intersection  -> [0]
					var intersections = this.raycaster.intersectObject(this.fileRepresentation)
					var intersection = ( intersections.length ) > 0 ? intersections[ 0 ] : null
					this.verticesPolygonTool.push(intersection.point)

					// create new preview polygon/shape when enough points are available
					if(this.verticesPolygonTool.length >= 3) {
							glScene.remove(this.previewPolygon)
							this.previewPolygon = this.createPolygon(this.verticesPolygonTool, 0x00ff00)
							glScene.add(this.previewPolygon)

					}
					this.render()


				break;
				default:

			}

		},
		createPolygon: function (vertices, color) {
			// IDEA: move to helper object?
			let polygon = new THREE.Geometry()
			polygon.vertices = vertices

			// calculate faces of preview polygon
			for (var i = 1; i < polygon.vertices.length - 1; i++) {
				polygon.faces.push( new THREE.Face3( 0, i, i+1 ) )
			}

			polygon.computeBoundingSphere()

				return new THREE.Mesh(
					polygon,
					new THREE.MeshBasicMaterial( {
						color: color,
						side: THREE.DoubleSide
					} )
				)
		},

		createLabel: function (text, point, multFactor, color) {
			let div = document.createElement('div')
			let textElement = document.createElement('span')
			div.style.opacity = '0.85'
			div.style.fontSize = '40px'
			div.style.padding = "0.35em"
			div.style.background = "rgb(255, 255, 255)"
			div.style.border = color + " solid 0.125em"
			div.style.transition = "opacity 0.5s"
			div.innerHTML = text
			div.addEventListener('mouseover', () => console.log('over'))
			let label = new THREE.CSS3DSprite(div)
			label.position.set(point.x, point.y, point.z)
			label.position.multiplyScalar(multFactor)
			return label
		},

		createArrow: function (point, multFactor, color) {
			var material = new THREE.LineBasicMaterial({
				color: color
			})

			var geometry = new THREE.Geometry()
			geometry.vertices.push(
				point,
				new THREE.Vector3().copy(point).multiplyScalar(multFactor)
			)

			return new THREE.Line( geometry, material )
		},

		toolChanged: function(e) {
			// this is render-view's event listener on the toolBox
			// when a different tool is selected, this function is triggered

			//do some cleanup/inits
			glScene.remove(this.previewPolygon)
			this.previewPolygon = undefined
			this.verticesPolygonTool = []

			// set this.modus.tool to the tool clicked in the box
			this.modus.tool = e.target.selected
			console.log(this.modus.tool)

			switch (this.modus.tool) {
				case 'polygon':

					break;
				default:

			}

			console.log(this.modus.tool)
		}

	})
	</script>

</dom-module>
