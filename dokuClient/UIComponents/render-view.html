<link rel="import" href="../bower_components/polymer/polymer.html">
<script src="../libs/three/three.min.js"></script>
<script src="../libs/three/controls/TrackballControls.js"></script>
<script src="../libs/three/renderers/CSS3DRenderer.js"></script>
<script src="../libs/three/loaders/STLLoader.js"></script>

<dom-module id="render-view">

	<template>
	<style is="custom-style">
	:host {
		margin: 0;
		cursor: -webkit-grab;
		min-height: 100%;
		min-width: 100%;
	}

	:host.track {
		cursor: -webkit-grabbing;
	}



	:host:hover {}

	canvas {
		width: 100%;
		height: 100%;
	}

	:host.polygonCursor {
		cursor: crosshair;

	}
		</style>

	</template>

	<script>
	'use strict' /*eslint global-strict:0*/

	// FIXME: shouldnt those global variables better reside inside the element
	// vis this.glRenderer = ...
	var glScene = new THREE.Scene();
	var cssScene = new THREE.Scene();
	var camera;
	var controls;
	var cssObject;
	var glRenderer;
	var cssRenderer;
	var render;
	var animate;

	Polymer({
		is: "render-view",
		properties: {
			fileRepresentation: Object,
			file: {
				type: Object,
				observer: '_fileChanged'
			},
			annotations: {
				type: Array,
				observer: "_annotationsChanged"
			}
		},
		listeners: {
			'up': 'toggleTrack',
			'down': 'toggleTrack',
			'mousemove': 'mouseMoved',
			'tap': 'tap'
		},

		ready: function() {
			// doesnt work with listeners on this very element
			// so create start event listener
			console.log('renderview ready')
			this.ready = true
			this.rendering = false
			document.addEventListener('keydown', this.keydown.bind(this))
		},
		startRendering: function() {
			if(this.rendering === false) {
				console.log('started rendering');
				this.rendering = true
				animate()
			}
		},
		animate: function () {
			requestAnimationFrame(this.animate.bind(this));
			controls.update();
		},
		render: function() {
			glRenderer.render(glScene, camera);
			cssRenderer.render(cssScene, camera);
		},

		resetGroups: function () {
			// create group for text annotations in 3D
			if(this.labelGroup && this.annotationGlGroups) {

				for( var i = this.labelGroup.children.length - 1; i >= 0; i--) {
					this.labelGroup.remove(this.labelGroup.children[i]);
					cssScene.remove(this.labelGroup.children[i]);
				}

				for( var i = this.annotationGlGroups.children.length - 1; i >= 0; i--) {
					this.annotationGlGroups.remove(this.annotationGlGroups.children[i]);
					cssScene.remove(this.annotationGlGroups.children[i]);
				}
			}

		},

		attached: function() {

			this.modus = {tool: '', modelGrabbing: false};
			// the render-view is interested in the state of the tool-box selector
			// lets add the event listener then
			var toolBox = Polymer.dom(this.parent).querySelector('#tool-box')
			if (toolBox) {
				toolBox.addEventListener('iron-select', this.toolChanged.bind(this))
				toolBox.addEventListener('iron-select', this.toolChanged.bind(this))
			} else {
				console.error('tool-box no found inside renderViews attached function. Maybe use different way to use toolbox?');
			}


			let width = this.parentNode.getBoundingClientRect().width
			let height = this.parentNode.getBoundingClientRect().height

			camera = new THREE.PerspectiveCamera(50, width / height, 0.01, 10000);
			camera.position.set(800, 800, 800);

			glRenderer = new THREE.WebGLRenderer({
				antialias: true,
				alpha: true
			});
			glRenderer.setClearColor(0x00ff00, 0.0);
			glRenderer.setSize(width, height);

			// let both renderers/canvases overlap
			glRenderer.domElement.style.position = 'absolute';
			glRenderer.domElement.style.top = 0;

			// cssRenderer is used for font rendering
			cssRenderer = new THREE.CSS3DRenderer();
			cssRenderer.setSize(width, height);

			glRenderer.domElement.id = 'glRenderer';
			cssRenderer.domElement.id = 'cssRenderer';
			Polymer.dom(this.root).appendChild(glRenderer.domElement);
			Polymer.dom(this.root).appendChild(cssRenderer.domElement);

			// create group for text annotations in 3D
			this.labelGroup = new THREE.Object3D();
			this.annotationGlGroups = new THREE.Object3D();
			cssScene.add(this.labelGroup);
			glScene.add(this.annotationGlGroups);
			this.resetGroups();

			// setup 3d-controls (rotating the camera with cursor)
			controls = new THREE.TrackballControls(camera, this);
			controls.rotateSpeed = 1.0;
			controls.zoomSpeed = 1.2;
			controls.panSpeed = 0.8;
			controls.noZoom = false;
			controls.noPan = false;
			controls.staticMoving = true;
			controls.dynamicDampingFactor = 0.3;
			controls.keys = [65, 83, 68];

			// add cursor pointer to 3D scene
			var sphereGeometry = new THREE.SphereGeometry( 5, 6, 6 );
			var sphereMaterial = new THREE.MeshBasicMaterial( {color: 0xff0000} );
			this.pointerSphere = new THREE.Mesh( sphereGeometry, sphereMaterial );
			glScene.add(this.pointerSphere);

			// create Raycaster used for polygon editing tool
			this.raycaster = new THREE.Raycaster()

			controls.addEventListener('change', this.render.bind(this))
			controls.addEventListener('change', this.updateAnnotationVisibility.bind(this))
			controls.handleResize()

			// init annotations to empty array
			this.annotations = [];
			this.annotation3DObjects = [];

			this.fire('initialized')
		},

		resize: function(event) {
			let width = this.parentNode.getBoundingClientRect().width;
			let height = this.parentNode.getBoundingClientRect().height;
			glRenderer.setSize(width, height);
			cssRenderer.setSize(width, height);
			camera.aspect = width / height;
			camera.updateProjectionMatrix();
			controls.handleResize();
			this.render();
		},

		_fileChanged: function () {
			console.log('fileChanged')
			console.log(this.file)

			this.resetGroups();
			this.annotations = [];

			// load the file and use it for display
			var loader = new THREE.STLLoader()
			var filepath = URL.createObjectURL(this.file)
			loader.load(filepath,
				geometry  => {
					var material = new THREE.MeshNormalMaterial({
						side: THREE.DoubleSide
					})
					var meshFromFile = new THREE.Mesh(geometry, material);

					var boundingBox = new THREE.Box3().setFromObject(meshFromFile);
					var maxLength = Math.max(boundingBox.max.x, boundingBox.max.y, boundingBox.max.z);
					// TODO: Save scale factor in DB.
					meshFromFile.scale.set(800/maxLength, 800/maxLength, 800/maxLength);
					var height = boundingBox.size().y;
					var pos = glScene.position;


					// swap existing mesh with new mesh
					glScene.add(meshFromFile)
					glScene.remove(this.fileRepresentation)
					this.fileRepresentation = meshFromFile
					this.render()
					this.animate()
				}
			);
		},

		_annotationsChanged: function() {
			console.log('_annotationsChanged');
			// debug output of annotations
			// first remove all previous annotations
			// FIXME: only update modified ones, instead of removing and completely re-creating
			this.resetGroups();


			for (let annotation of this.annotations) {
				let annotation3DObject = {};
				let annotationGlGroup = new THREE.Object3D();
				let multFactor = 2;
				let label = this.createLabel(annotation, multFactor);
				this.labelGroup.add(label);
				annotation3DObject.label = label;

				// TODO: add arrow, label to a group/structure to be selectable
				let arrow = this.createArrow(annotation.position, label.position, annotation.creatorProfile.color);
				annotationGlGroup.add(arrow);
				annotation3DObject.arrow = arrow;

				// if annotation has polygon info, create it and add it to the scene
				if(annotation.polygon !== undefined) {
					let polygon = this.createPolygon(annotation.polygon, annotation.creatorProfile.color)
					annotationGlGroup.add(polygon)
					annotation3DObject.polygon = polygon
				}
				this.annotationGlGroups.add(annotationGlGroup);
				this.annotation3DObjects.push(annotation3DObject);
			}
			this.render();
		},

		updateAnnotationVisibility: function () {
			// TODO: there is a PR on threejs for raycasting in css renderer, use it once ready
			// triggered on controls update
			let raycaster = new THREE.Raycaster()

			if(this.labelGroup.children === undefined) return

			for(let label of this.labelGroup.children) {
				let normalizedDirection = (label.position.clone().sub(camera.position)).normalize()
				raycaster.set(camera.position.clone(), normalizedDirection)
				raycaster.far = camera.position.distanceTo(label.position)
				let intersections = raycaster.intersectObject(this.fileRepresentation)
				if(intersections.length !== 0) {
					label.element.style.opacity = 0.0
				} else {
					label.element.style.opacity = 0.8
				}
			}
			this.render()

		},

		toggleTrack: function(e) {
			this.modus.modelGrabbing = !this.modus.modelGrabbing
			Polymer.dom(this).classList.toggle('track')
		},

		updateMouse: function (mouseEvent) {
			let canvas = this.$$('canvas')
			this.mouse = new THREE.Vector2(
				(mouseEvent.layerX / canvas.width) * 2 - 1,
				-((mouseEvent.layerY / canvas.height) * 2 - 1)
			);
		},

		mouseMoved: function (e) {
			if(this.modus.tool === 'polygon') {
				this.updateMouse(e)
				this.raycaster.setFromCamera(this.mouse, camera)

				let intersections = [];
				if(this.fileRepresentation) {
					intersections = this.raycaster.intersectObject(this.fileRepresentation)
				}

				if(intersections.length !== 0){
					if(this.modus.modelGrabbing === false)
						Polymer.dom(this).classList.add('polygonCursor')
					this.pointerSphere.position.set(intersections[0].point.x, intersections[0].point.y , intersections[0].point.z)
					this.render()
				} else {
					Polymer.dom(this).classList.remove('polygonCursor')
				}
			}
		},

		keydown: function (e) {
			if (e.defaultPrevented) {
				return; // Should do nothing if the key event was already consumed.
			}

			switch (e.keyIdentifier) {
				case 'Enter':
					if(this.modus.tool === 'polygon' && this.verticesPolygonTool.length !== 0){
						// TODO: finish shape and create annotation

						this.fire('create-annotation', {
							description: 'new polygon...',
							polygon: this.verticesPolygonTool,
							position: this.verticesPolygonTool[0],
							cameraPosition: camera.position,
							// cameraRotation: camera.rotation,
							cameraUp: camera.up
						})

						glScene.remove(this.previewPolygon)
						this.previewPolygon = undefined
						this.verticesPolygonTool = []
						console.log('added polygon annotation')
					}
					break;
				default:

			}

		},
		tap: function(e) {
			console.log(this.modus.tool)
			switch (this.modus.tool) {
				case 'polygon':

					this.updateMouse(e.detail.sourceEvent)

					// update the picking ray with the camera and mouse position
					this.raycaster.setFromCamera(this.mouse, camera);

					// calculate objects intersecting the picking ray
					// only use the frontmost intersection  -> [0]
					var intersections = this.raycaster.intersectObject(this.fileRepresentation)
					var intersection = ( intersections.length ) > 0 ? intersections[ 0 ] : null
					this.verticesPolygonTool.push(intersection.point)

					// create new preview polygon/shape when enough points are available
					if(this.verticesPolygonTool.length >= 3) {
							glScene.remove(this.previewPolygon)
							this.previewPolygon = this.createPolygon(this.verticesPolygonTool, 0x00ff00)
							glScene.add(this.previewPolygon)

					}
					this.render()


				break;
				default:

			}

		},
		createPolygon: function (vertices, color) {
			// IDEA: move to helper object?
			let polygon = new THREE.Geometry()
			polygon.vertices = vertices

			// calculate faces of preview polygon
			for (var i = 1; i < polygon.vertices.length - 1; i++) {
				polygon.faces.push( new THREE.Face3( 0, i, i+1 ) )
			}

			polygon.computeBoundingSphere()

				return new THREE.Mesh(
					polygon,
					new THREE.MeshBasicMaterial( {
						color: color,
						side: THREE.DoubleSide
					} )
				)
		},

		createLabel: function (annotation, multFactor) {
			let div = document.createElement('div');
			let textElement = document.createElement('span');
			div.style.opacity = '0.85';
			div.style.fontSize = '40px';
			div.style.padding = "0.35em";
			div.style.background = "rgb(255, 255, 255)";
			div.style.border = annotation.creatorProfile.color + " solid 0.125em";
			div.style.transition = "opacity 0.5s";
			div.innerHTML = annotation.description;
			div.addEventListener('mouseover', (e) => {
				this.fire('label-over', annotation._id);
			});
			div.addEventListener('mouseout', (e) => {
				this.fire('label-out', annotation._id);
			});
			let label = new THREE.CSS3DSprite(div);

			if (annotation.cameraPosition !== undefined) {
				let pointToCam = new THREE.Vector3().subVectors(annotation.cameraPosition, annotation.position);
				pointToCam.multiplyScalar(0.8);
				label.position.copy(pointToCam);
			} else {
				label.position.set(annotation.position.x, annotation.position.y, annotation.position.z);
				label.position.multiplyScalar(multFactor);
			}
			return label;
		},

		createArrow: function (point, labelpos, color) {
			var material = new THREE.LineBasicMaterial({
				color: color
			})

			var geometry = new THREE.Geometry()
			geometry.vertices.push(
				point,
				labelpos
			)

			return new THREE.Line( geometry, material )
		},

		toolChanged: function(e) {
			// this is render-view's event listener on the toolBox
			// when a different tool is selected, this function is triggered

			//do some cleanup/inits
			glScene.remove(this.previewPolygon)
			this.previewPolygon = undefined
			this.verticesPolygonTool = []

			// set this.modus.tool to the tool clicked in the box
			this.modus.tool = e.target.selected

			switch (this.modus.tool) {
				case 'polygon':

					break;
				default:

			}
		},
		focusAnnotation: function (annotation) {

			if(annotation.cameraPosition !== undefined) {
				// The resetFrom function was added by me (modified .reset()) to allow
				// reset from a saved position (eg. stored in the DB)
				controls.resetFrom(annotation.cameraPosition, annotation.cameraUp);
			} else {
				return;
			}

		}

	})
	</script>

</dom-module>
